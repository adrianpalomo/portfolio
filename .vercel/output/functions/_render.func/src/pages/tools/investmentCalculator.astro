---
import BasicLayout from "@/layouts/BasicLayout.astro";

const defaultAssets = [
  {
    id: "msci",
    name: "MSCI World",
    current: null,
    price: null,
    isin: null,
    target: 60,
    wholeUnits: false,
  },
  {
    id: "emergentes",
    name: "Mercados emergentes",
    current: null,
    price: null,
    isin: null,
    target: 10,
    wholeUnits: false,
  },
  {
    id: "btc",
    name: "BTC",
    current: null,
    price: null,
    isin: null,
    target: 15,
    wholeUnits: true,
  },
  {
    id: "oro",
    name: "Oro",
    current: null,
    price: null,
    isin: null,
    target: 15,
    wholeUnits: true,
  },
];
---

<BasicLayout title="Calculadora de Inversión | Adrian Palomo">
  <div
    class="min-h-screen bg-gray-900 px-3 py-4 font-sans text-gray-100 sm:px-4 md:px-6 lg:px-8"
  >
    <h1 class="mb-4 text-2xl font-bold text-blue-500 sm:mb-6 sm:text-3xl">
      Calculadora de inversión
    </h1>

    <div class="mx-auto w-full">
      <div
        class="mb-4 rounded-lg border border-gray-700 bg-gray-800 p-4 shadow-lg sm:mb-6 sm:p-6"
      >
        <div class="mb-4">
          <p class="text-sm text-gray-300 sm:text-base">
            Ajusta los pesos objetivo, define si puedes comprar fracciones y
            establece un presupuesto y un margen de tolerancia para evitar
            rebalanceos excesivos.
          </p>
        </div>

        <form id="allocation-form" novalidate>
          <div
            class="mb-4 grid grid-cols-1 gap-3 sm:mb-6 sm:gap-4 md:grid-cols-2"
          >
            <div
              class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4"
            >
              <div
                class="mb-2 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between"
              >
                <label
                  for="budget"
                  class="block text-sm font-medium text-gray-300"
                >
                  Dinero disponible (&euro;)
                </label>
                <div class="flex items-center gap-2">
                  <span class="text-xs text-gray-400 sm:text-sm"
                    >Permitir traspasos</span
                  >
                  <button
                    type="button"
                    id="allow-transfers"
                    role="switch"
                    aria-checked="false"
                    aria-label="Permitir ventas para rebalancear"
                    class="relative inline-flex h-7 w-12 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none"
                  >
                    <span
                      class="inline-block h-5 w-5 translate-x-1 transform rounded-full bg-white transition-transform"
                    ></span>
                  </button>
                </div>
              </div>
              <input
                id="budget"
                name="budget"
                type="number"
                min="0"
                step="0.01"
                placeholder="Ej. 500"
                class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
              />
              <small class="mt-2 block text-xs text-blue-400">
                Déjalo vacío para obtener la aportación mínima sin límite.
              </small>
            </div>
            <div
              class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4"
            >
              <label
                for="margin"
                class="mb-2 block text-sm font-medium text-gray-300"
              >
                Margen de error (+/- %)
              </label>
              <input
                id="margin"
                name="margin"
                type="number"
                min="0"
                max="20"
                step="0.1"
                value="1"
                class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
              />
              <small class="mt-2 block text-xs text-blue-400">
                Evita perseguir el porcentaje exacto; permite una banda segura.
              </small>
            </div>
          </div>

          <!-- Horizon Calculator Panel -->
          <div
            class="mb-4 overflow-hidden rounded-lg border border-purple-500/30 bg-purple-950/10 sm:mb-6"
          >
            <button
              type="button"
              id="horizon-toggle"
              class="flex w-full items-center justify-between px-4 py-3 text-left transition-colors hover:bg-purple-950/50 focus:ring-2 focus:ring-purple-800 focus:outline-none"
            >
              <div class="flex items-center gap-2">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5 text-purple-400"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"
                  ></path>
                </svg>
                <span class="text-base font-semibold text-purple-300 sm:text-lg"
                  >Calculadora de horizontes</span
                >
              </div>
              <svg
                id="horizon-chevron"
                xmlns="http://www.w3.org/2000/svg"
                class="h-5 w-5 text-purple-400 transition-transform duration-200"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fill-rule="evenodd"
                  d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                  clip-rule="evenodd"></path>
              </svg>
            </button>

            <div
              id="horizon-panel"
              class="hidden space-y-4 border-t border-purple-500/20 p-4 sm:p-5"
            >
              <p class="text-sm text-gray-400">
                Calcula horizontes de inversión. Rellena 2 de los 3 campos
                (inversión mensual, dinero objetivo y tiempo) y se calculará el
                tercero automáticamente.
              </p>

              <!-- Modo de cálculo -->
              <div class="grid grid-cols-1 gap-3 sm:grid-cols-3">
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-monthly"
                    class="text-sm font-medium text-gray-300"
                    >Inversión mensual (&euro;)</label
                  >
                  <input
                    id="hz-monthly"
                    type="number"
                    min="0"
                    step="1"
                    placeholder="Ej. 500"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                </div>
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-target"
                    class="text-sm font-medium text-gray-300"
                    >Dinero objetivo (&euro;)</label
                  >
                  <input
                    id="hz-target"
                    type="number"
                    min="0"
                    step="1"
                    placeholder="Ej. 100000"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                </div>
                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300"
                    >Horizonte temporal</label
                  >
                  <div class="flex gap-2">
                    <input
                      id="hz-months"
                      type="number"
                      min="1"
                      step="1"
                      placeholder="Meses"
                      class="w-1/2 rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                    />
                    <input
                      id="hz-date"
                      type="month"
                      class="w-1/2 rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                    />
                  </div>
                  <small class="text-xs text-purple-400"
                    >Usa meses o fecha. La fecha prevalece si ambas están
                    rellenas.</small
                  >
                </div>
              </div>

              <!-- Capital inicial y reparto -->
              <div class="grid grid-cols-1 gap-3 sm:grid-cols-2 lg:grid-cols-4">
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-initial"
                    class="text-sm font-medium text-gray-300"
                    >Capital inicial (&euro;)</label
                  >
                  <input
                    id="hz-initial"
                    type="number"
                    min="0"
                    step="1"
                    value="0"
                    placeholder="0"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                  <a
                    href="#"
                    id="hz-use-current"
                    class="text-xs text-purple-400 hover:text-purple-300 hover:underline"
                    >Usar total del reparto actual</a
                  >
                </div>
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-rv-pct"
                    id="hz-rv-label"
                    class="text-sm font-medium text-gray-300"
                    >Renta variable (%)</label
                  >
                  <input
                    id="hz-rv-pct"
                    type="number"
                    min="0"
                    max="100"
                    step="1"
                    value="70"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                  <div class="flex items-center justify-between">
                    <small class="text-xs text-gray-500"
                      >El resto va a renta fija</small
                    >
                    <a
                      href="#"
                      id="hz-rv-mode-toggle"
                      class="text-xs text-purple-400 hover:text-purple-300 hover:underline"
                      >Cambiar a &euro;</a
                    >
                  </div>
                </div>
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-rv-tae"
                    class="text-sm font-medium text-gray-300"
                    >TAE renta variable (%)</label
                  >
                  <input
                    id="hz-rv-tae"
                    type="number"
                    min="-50"
                    max="100"
                    step="0.1"
                    value="8"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                </div>
                <div class="flex flex-col gap-2">
                  <label
                    for="hz-rf-tae"
                    class="text-sm font-medium text-gray-300"
                    >TAE renta fija (%)</label
                  >
                  <input
                    id="hz-rf-tae"
                    type="number"
                    min="-50"
                    max="100"
                    step="0.1"
                    value="2"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                  />
                </div>
              </div>

              <!-- Campo calculado indicator -->
              <div
                id="hz-calc-indicator"
                class="hidden rounded-lg border border-purple-500/20 bg-purple-950/20 p-3 text-sm text-purple-300"
              >
              </div>

              <!-- Resultados -->
              <div id="hz-results" class="hidden space-y-4">
                <!-- Summary cards -->
                <div
                  id="hz-summary"
                  class="grid grid-cols-2 gap-3 sm:grid-cols-3 lg:grid-cols-6"
                >
                </div>

                <!-- Tabla de progresión -->
                <div
                  class="overflow-x-auto rounded-lg border border-gray-700 bg-gray-800"
                >
                  <table class="w-full text-sm">
                    <thead class="border-b border-gray-700 bg-gray-900">
                      <tr>
                        <th
                          class="px-3 py-2 text-left text-xs font-medium text-gray-300"
                          >Año</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-gray-300"
                          >Invertido</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-green-400"
                          >R. variable</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-blue-400"
                          >R. fija</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-gray-300"
                          >Total</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-emerald-400"
                          >Ganancia</th
                        >
                        <th
                          class="px-3 py-2 text-right text-xs font-medium text-emerald-400"
                          >% Ganancia</th
                        >
                      </tr>
                    </thead>
                    <tbody id="hz-table-body" class="divide-y divide-gray-700"
                    ></tbody>
                  </table>
                </div>

                <!-- Gráfico -->
                <div class="rounded-lg border border-gray-700 bg-gray-800 p-4">
                  <h4 class="mb-3 text-base font-semibold text-gray-100">
                    Evolución del patrimonio
                  </h4>
                  <div class="relative" style="height:350px">
                    <canvas id="hz-chart" class="h-full w-full"></canvas>
                  </div>
                  <div
                    id="hz-chart-legend"
                    class="mt-3 flex flex-wrap justify-center gap-4 text-xs text-gray-300"
                  >
                  </div>
                </div>
              </div>

              <!-- Error -->
              <p
                id="hz-error"
                class="hidden rounded-lg border border-red-500/50 bg-red-950/30 p-3 text-sm text-red-400"
                role="alert"
              >
              </p>
            </div>
          </div>

          <div
            class="mb-4 rounded-lg border border-gray-700 bg-gray-800/50 p-4 sm:mb-6 sm:p-5"
          >
            <div
              class="mb-3 flex flex-col gap-2 sm:mb-4 sm:flex-row sm:items-center sm:justify-between"
            >
              <h2 class="text-lg font-semibold text-gray-100 sm:text-xl">
                Reparto actual
              </h2>
              <span
                id="current-total-label"
                class="text-base font-bold text-blue-400 sm:text-lg">-</span
              >
            </div>
            <ul
              id="current-distribution"
              class="grid grid-cols-1 gap-2 sm:grid-cols-2 lg:grid-cols-3"
            >
              <li
                class="rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400"
              >
                Introduce los valores actuales para ver el reparto porcentual.
              </li>
            </ul>
          </div>

          <div class="mb-4 space-y-3 sm:mb-6 sm:space-y-4" id="rows-container">
            {
              defaultAssets.map((asset) => (
                <div
                  class="relative rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-md sm:p-4"
                  data-row
                >
                  <button
                    type="button"
                    data-action="delete-row"
                    class="absolute top-2 right-2 rounded-md p-1.5 text-gray-400 transition-colors hover:bg-red-600/20 hover:text-red-400 focus:ring-2 focus:ring-red-500 focus:outline-none"
                    title="Eliminar activo"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      class="h-5 w-5"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                    >
                      <path
                        fill-rule="evenodd"
                        d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z"
                        clip-rule="evenodd"
                      />
                    </svg>
                  </button>
                  <div class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-8">
                    <div class="flex flex-col gap-2">
                      <label class="text-sm font-medium text-gray-300">
                        ISIN
                      </label>
                      <input
                        data-field="isin"
                        type="text"
                        value={asset.isin || ""}
                        placeholder="ES0123456789"
                        class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                      />
                    </div>

                    <div class="flex flex-col gap-2 lg:col-span-2">
                      <label class="text-sm font-medium text-gray-300">
                        Activo
                      </label>
                      <input
                        data-field="name"
                        type="text"
                        required
                        value={asset.name}
                        class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                      />
                    </div>

                    <div class="flex flex-col gap-2">
                      <label class="text-sm font-medium text-gray-300">
                        Valor actual (&euro;)
                      </label>
                      <input
                        data-field="current"
                        type="number"
                        min="0"
                        step="0.01"
                        required
                        value={asset.current}
                        class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                      />
                    </div>

                    <div class="flex flex-col gap-2" data-price-wrapper>
                      <label class="text-sm font-medium text-gray-300">
                        Precio unidad (&euro;)
                      </label>
                      <input
                        data-field="price"
                        type="number"
                        min="0"
                        step="0.01"
                        value={asset.price || ""}
                        disabled={!asset.wholeUnits}
                        class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
                      />
                    </div>

                    <div class="flex flex-col gap-2">
                      <label class="text-sm font-medium text-gray-300">
                        ¿Solo unidades completas?
                      </label>
                      <button
                        type="button"
                        role="switch"
                        data-field="whole"
                        aria-checked={asset.wholeUnits ? "true" : "false"}
                        aria-label={`Activar unidades completas para ${asset.name}`}
                        class={`relative inline-flex h-8 w-14 items-center rounded-full transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none ${asset.wholeUnits ? "bg-blue-600" : "bg-gray-600"}`}
                      >
                        <span
                          class={`inline-block h-6 w-6 transform rounded-full bg-white transition-transform ${asset.wholeUnits ? "translate-x-7" : "translate-x-1"}`}
                        />
                      </button>
                    </div>

                    <div class="flex flex-col gap-2">
                      <label class="text-sm font-medium text-gray-300">
                        Objetivo (%)
                      </label>
                      <input
                        data-field="target"
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        required
                        value={asset.target}
                        class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                      />
                    </div>

                    <div class="flex flex-col gap-2">
                      <label class="text-sm font-medium text-gray-300">
                        Incluir en cálculo
                      </label>
                      <button
                        type="button"
                        role="switch"
                        data-field="included"
                        aria-checked={
                          typeof (asset as any).includedInCalculation ===
                            "undefined" || (asset as any).includedInCalculation
                            ? "true"
                            : "false"
                        }
                        aria-label={`Incluir ${asset.name} en el cálculo`}
                        class={`relative inline-flex h-8 w-14 items-center rounded-full transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none ${typeof (asset as any).includedInCalculation === "undefined" || (asset as any).includedInCalculation ? "bg-blue-600" : "bg-gray-600"}`}
                      >
                        <span
                          class={`inline-block h-6 w-6 transform rounded-full bg-white transition-transform ${typeof (asset as any).includedInCalculation === "undefined" || (asset as any).includedInCalculation ? "translate-x-7" : "translate-x-1"}`}
                        />
                      </button>
                    </div>
                  </div>
                </div>
              ))
            }
          </div>

          <button
            type="button"
            id="add-row-btn"
            class="mb-3 rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:mb-4 sm:px-6"
          >
            + Añadir activo
          </button>

          <p class="mb-4 text-sm text-gray-400">
            Activa el toggle cuando solo puedas comprar unidades completas; el
            campo de precio se habilitará automáticamente. Los cálculos se
            actualizan en tiempo real.
          </p>

          <div class="flex flex-wrap gap-2">
            <button
              id="reset-btn"
              type="button"
              class="rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:px-8 sm:py-3"
            >
              Restablecer
            </button>
            <button
              id="export-btn"
              type="button"
              class="rounded-md border border-blue-600 bg-blue-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-blue-600 sm:px-8 sm:py-3"
            >
              Exportar
            </button>
            <button
              id="import-btn"
              type="button"
              class="rounded-md border border-green-600 bg-green-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-green-600 sm:px-8 sm:py-3"
            >
              Importar
            </button>
            <input type="file" id="import-file" accept=".json" class="hidden" />
          </div>

          <template id="row-template">
            <div
              class="relative rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-md sm:p-4"
              data-row
            >
              <button
                type="button"
                data-action="delete-row"
                class="absolute top-2 right-2 rounded-md p-1.5 text-gray-400 transition-colors hover:bg-red-600/20 hover:text-red-400 focus:ring-2 focus:ring-red-500 focus:outline-none"
                title="Eliminar activo"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z"
                    clip-rule="evenodd"></path>
                </svg>
              </button>
              <div
                class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-8"
              >
                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300">
                    ISIN
                  </label>
                  <input
                    data-field="isin"
                    type="text"
                    placeholder="ES0123456789"
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  />
                </div>

                <div class="flex flex-col gap-2 lg:col-span-2">
                  <label class="text-sm font-medium text-gray-300">
                    Activo
                  </label>
                  <input
                    data-field="name"
                    type="text"
                    required
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  />
                </div>

                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300">
                    Valor actual (&euro;)
                  </label>
                  <input
                    data-field="current"
                    type="number"
                    min="0"
                    step="0.01"
                    required
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  />
                </div>

                <div class="flex flex-col gap-2" data-price-wrapper>
                  <label class="text-sm font-medium text-gray-300">
                    Precio unidad (&euro;)
                  </label>
                  <input
                    data-field="price"
                    type="number"
                    min="0"
                    step="0.01"
                    disabled
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
                  />
                </div>

                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300">
                    ¿Solo unidades completas?
                  </label>
                  <button
                    type="button"
                    role="switch"
                    data-field="whole"
                    aria-checked="false"
                    aria-label="Activar unidades completas"
                    class="relative inline-flex h-8 w-14 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none"
                  >
                    <span
                      class="inline-block h-6 w-6 translate-x-1 transform rounded-full bg-white transition-transform"
                    ></span>
                  </button>
                </div>

                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300">
                    Objetivo (%)
                  </label>
                  <input
                    data-field="target"
                    type="number"
                    min="0"
                    max="100"
                    step="0.1"
                    required
                    class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  />
                </div>

                <div class="flex flex-col gap-2">
                  <label class="text-sm font-medium text-gray-300">
                    Incluir en cálculo
                  </label>
                  <button
                    type="button"
                    role="switch"
                    data-field="included"
                    aria-checked="true"
                    aria-label="Incluir en el cálculo"
                    class="relative inline-flex h-8 w-14 items-center rounded-full bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none"
                  >
                    <span
                      class="inline-block h-6 w-6 translate-x-7 transform rounded-full bg-white transition-transform"
                    ></span>
                  </button>
                </div>
              </div>
            </div>
          </template>
        </form>

        <div id="results" class="mt-4 space-y-4 sm:mt-6 sm:space-y-6" hidden>
          <div
            id="summary"
            class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-3"
          >
          </div>

          <p
            id="advice"
            class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-3 text-sm text-gray-200 sm:p-4 sm:text-base"
          >
          </p>

          <div
            class="overflow-x-auto rounded-lg border border-gray-700 bg-gray-800"
          >
            <table class="w-full">
              <thead class="border-b border-gray-700 bg-gray-900">
                <tr>
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >Activo</th
                  >
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >Actual</th
                  >
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >Objetivo</th
                  >
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >Aportar</th
                  >
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                  >
                    Tu aportación
                  </th>
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >Unid.</th
                  >
                  <th
                    class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm"
                    >% final</th
                  >
                </tr>
              </thead>
              <tbody id="results-body" class="divide-y divide-gray-700"></tbody>
            </table>
          </div>

          <div
            id="step-guide"
            class="rounded-lg border border-gray-700 bg-gray-800 p-4 sm:p-6"
          >
            <h3 class="mb-4 text-lg font-semibold text-gray-100 sm:text-xl">
              Paso a paso
            </h3>
            <ol
              id="step-list"
              class="space-y-3 text-sm text-gray-300 sm:text-base"
            >
            </ol>
          </div>
        </div>

        <p
          id="error"
          class="mt-4 rounded-lg border border-red-500/50 bg-red-950/30 p-3 text-sm text-red-400 sm:mt-6 sm:p-4"
          role="alert"
          hidden
        >
        </p>
      </div>
    </div>
  </div>

  <script type="module" define:vars={{ defaultAssets }}>
    const initialAssets = defaultAssets;
    const form = document.querySelector("#allocation-form");
    const rowsContainer = document.querySelector("#rows-container");
    const rowTemplate = document.querySelector("#row-template");
    const addRowBtn = document.querySelector("#add-row-btn");
    const budgetInput = document.querySelector("#budget");
    const marginInput = document.querySelector("#margin");
    const transfersToggle = document.querySelector("#allow-transfers");
    const distributionList = document.querySelector("#current-distribution");
    const currentTotalLabel = document.querySelector("#current-total-label");
    const resultsSection = document.querySelector("#results");
    const summaryEl = document.querySelector("#summary");
    const adviceEl = document.querySelector("#advice");
    const tbody = document.querySelector("#results-body");
    const stepGuide = document.querySelector("#step-guide");
    const stepList = document.querySelector("#step-list");
    const errorBox = document.querySelector("#error");
    const resetBtn = document.querySelector("#reset-btn");
    const exportBtn = document.querySelector("#export-btn");
    const importBtn = document.querySelector("#import-btn");
    const importFileInput = document.querySelector("#import-file");

    const numberFormatter = new Intl.NumberFormat("es-ES", {
      style: "currency",
      currency: "EUR",
      minimumFractionDigits: 2,
    });

    const percentFormatter = new Intl.NumberFormat("es-ES", {
      style: "percent",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });

    const unitFormatter = new Intl.NumberFormat("es-ES", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 4,
    });

    const marginNumberFormatter = new Intl.NumberFormat("es-ES", {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2,
    });

    const clamp = (value, min = 0, max = 1) =>
      Math.min(Math.max(value, min), max);

    const sanitize = (value) => {
      if (typeof value !== "string") return 0;
      return Number(value.replace(",", ".")) || 0;
    };

    // Función para refrescar todos los precios de ISINs en el formulario
    const refreshAllPrices = () => {
      const rows = rowsContainer.querySelectorAll("[data-row]");
      rows.forEach((row) => {
        const isinInput = row.querySelector('[data-field="isin"]');
        const priceInput = row.querySelector('[data-field="price"]');
        const wholeToggle = row.querySelector('[data-field="whole"]');

        const isin = isinInput?.value?.trim().toUpperCase();
        const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;

        // Solo intentar si hay un ISIN válido
        if (
          isin &&
          isinRegex.test(isin) &&
          isinInput &&
          priceInput &&
          wholeToggle
        ) {
          const isETF = wholeToggle.getAttribute("aria-checked") === "true";
          // Añadir un pequeño delay entre requests para no sobrecargar
          setTimeout(() => {
            fetchPriceByISIN(isin, priceInput, isinInput, isETF);
          }, Math.random() * 1000); // Random delay 0-1s
        }
      });
    };

    // Función para obtener el precio de un fondo por ISIN
    const fetchPriceByISIN = async (isin, priceInput, isinInput, isETF) => {
      // Validar que el ISIN no esté vacío
      if (!isin || isin.trim().length === 0) {
        console.warn("ISIN vacío o inválido:", isin);
        return;
      }

      // Mostrar estado de carga
      isinInput.classList.remove("border-yellow-500", "border-green-500");
      isinInput.classList.add("border-blue-500");
      isinInput.title = "Buscando precio...";

      try {
        // Normalizar ISIN antes de enviarlo
        const normalizedIsin = isin.trim().toUpperCase();

        // Construir URL con query params
        const params = new URLSearchParams();
        params.set("isin", normalizedIsin);
        params.set("isETF", isETF ? "true" : "false");
        const apiUrl = `/api/fund-price?${params.toString()}`;

        // Llamar al endpoint API de Astro que hace el fetch desde el servidor
        // Esto evita problemas de CORS mediante web scraping
        const response = await fetch(apiUrl, {
          method: "GET",
          headers: {
            Accept: "application/json",
          },
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || "No se pudo obtener el precio");
        }

        const data = await response.json();

        if (data.price && data.price > 0) {
          // Precio obtenido exitosamente
          priceInput.value = data.price.toFixed(4);

          // Actualizar el nombre si viene en la respuesta
          if (data.name) {
            const row = priceInput.closest("[data-row]");
            const nameInput = row.querySelector('[data-field="name"]');
            // Solo actualizar si está vacío o es un nombre genérico
            if (!nameInput.value || nameInput.value.startsWith("Activo ")) {
              nameInput.value = data.name;
            }
          }

          // Habilitar el campo de precio si el toggle está activado
          const row = priceInput.closest("[data-row]");
          const wholeToggle = row.querySelector('[data-field="whole"]');
          if (wholeToggle.getAttribute("aria-checked") === "true") {
            priceInput.disabled = false;
          }

          // Actualizar estilos
          isinInput.classList.remove("border-blue-500");
          isinInput.classList.add("border-green-500");
          isinInput.title = "Precio obtenido correctamente";

          // Actualizar cálculos
          saveFormState();
          updateCurrentDistribution();
          autoCalculate();
        } else {
          throw new Error(data.message || "Precio no disponible");
        }
      } catch (error) {
        // Si falla, mostrar mensaje al usuario
        console.warn("Error al obtener precio por ISIN:", error);

        isinInput.classList.remove("border-blue-500");
        isinInput.classList.add("border-yellow-500");
        isinInput.title =
          'No se pudo obtener el precio automáticamente. Introdúcelo manualmente en el campo "Precio unidad".';

        // Habilitar el campo de precio para entrada manual si el toggle está activado
        const row = priceInput.closest("[data-row]");
        const wholeToggle = row.querySelector('[data-field="whole"]');
        if (wholeToggle.getAttribute("aria-checked") === "true") {
          priceInput.disabled = false;
          priceInput.focus();
        }
      }
    };

    const getMarginValue = () => {
      const raw = marginInput.value.trim();
      const fallback = raw === "" ? 1 : sanitize(raw);
      return Math.max(0, fallback);
    };

    const getMarginFraction = () => getMarginValue() / 100;

    const setTransfersToggle = (enabled) => {
      const state = Boolean(enabled);
      transfersToggle.setAttribute("aria-checked", state);
      if (state) {
        transfersToggle.classList.remove("bg-gray-600");
        transfersToggle.classList.add("bg-blue-600");
        transfersToggle.querySelector("span").classList.remove("translate-x-1");
        transfersToggle.querySelector("span").classList.add("translate-x-6");
      } else {
        transfersToggle.classList.remove("bg-blue-600");
        transfersToggle.classList.add("bg-gray-600");
        transfersToggle.querySelector("span").classList.remove("translate-x-6");
        transfersToggle.querySelector("span").classList.add("translate-x-1");
      }
    };

    const transfersEnabled = () =>
      transfersToggle.getAttribute("aria-checked") === "true";

    const initializeRow = (row, data = {}) => {
      const inputMap = {
        name: row.querySelector('[data-field="name"]'),
        isin: row.querySelector('[data-field="isin"]'),
        current: row.querySelector('[data-field="current"]'),
        price: row.querySelector('[data-field="price"]'),
        target: row.querySelector('[data-field="target"]'),
        whole: row.querySelector('[data-field="whole"]'),
        included: row.querySelector('[data-field="included"]'),
      };

      if (data.name) inputMap.name.value = data.name;
      if (data.isin) inputMap.isin.value = data.isin;
      if (typeof data.current !== "undefined")
        inputMap.current.value = data.current;
      if (typeof data.price !== "undefined" && data.price !== 0)
        inputMap.price.value = data.price;
      if (typeof data.target !== "undefined")
        inputMap.target.value = data.target;

      // Inicializar estado del toggle de unidades completas
      const isChecked = Boolean(data.wholeUnits);
      inputMap.whole.setAttribute("aria-checked", isChecked);
      if (isChecked) {
        inputMap.whole.classList.remove("bg-gray-600");
        inputMap.whole.classList.add("bg-blue-600");
        inputMap.whole.querySelector("span").classList.remove("translate-x-1");
        inputMap.whole.querySelector("span").classList.add("translate-x-7");
      }

      // Inicializar estado del toggle de inclusión en cálculo
      const isIncluded =
        typeof data.includedInCalculation === "undefined"
          ? true
          : Boolean(data.includedInCalculation);
      inputMap.included.setAttribute("aria-checked", isIncluded);
      if (isIncluded) {
        inputMap.included.classList.remove("bg-gray-600");
        inputMap.included.classList.add("bg-blue-600");
        inputMap.included
          .querySelector("span")
          .classList.remove("translate-x-1");
        inputMap.included.querySelector("span").classList.add("translate-x-7");
      } else {
        inputMap.included.classList.remove("bg-blue-600");
        inputMap.included.classList.add("bg-gray-600");
        inputMap.included
          .querySelector("span")
          .classList.remove("translate-x-7");
        inputMap.included.querySelector("span").classList.add("translate-x-1");
      }

      const updatePriceState = () => {
        const enabled = inputMap.whole.getAttribute("aria-checked") === "true";
        inputMap.price.disabled = !enabled;
        inputMap.price.required = enabled;
      };

      // Manejar click en el toggle
      inputMap.whole.addEventListener("click", () => {
        const isChecked =
          inputMap.whole.getAttribute("aria-checked") === "true";
        const newState = !isChecked;

        inputMap.whole.setAttribute("aria-checked", newState);
        if (newState) {
          inputMap.whole.classList.remove("bg-gray-600");
          inputMap.whole.classList.add("bg-blue-600");
          inputMap.whole
            .querySelector("span")
            .classList.remove("translate-x-1");
          inputMap.whole.querySelector("span").classList.add("translate-x-7");
        } else {
          inputMap.whole.classList.remove("bg-blue-600");
          inputMap.whole.classList.add("bg-gray-600");
          inputMap.whole
            .querySelector("span")
            .classList.remove("translate-x-7");
          inputMap.whole.querySelector("span").classList.add("translate-x-1");
        }

        updatePriceState();
        saveFormState();
        autoCalculate();
      });

      updatePriceState();

      // Manejar click en el toggle de inclusión
      inputMap.included.addEventListener("click", () => {
        const isChecked =
          inputMap.included.getAttribute("aria-checked") === "true";
        const newState = !isChecked;

        inputMap.included.setAttribute("aria-checked", newState);
        if (newState) {
          inputMap.included.classList.remove("bg-gray-600");
          inputMap.included.classList.add("bg-blue-600");
          inputMap.included
            .querySelector("span")
            .classList.remove("translate-x-1");
          inputMap.included
            .querySelector("span")
            .classList.add("translate-x-7");
        } else {
          inputMap.included.classList.remove("bg-blue-600");
          inputMap.included.classList.add("bg-gray-600");
          inputMap.included
            .querySelector("span")
            .classList.remove("translate-x-7");
          inputMap.included
            .querySelector("span")
            .classList.add("translate-x-1");
        }

        saveFormState();
        updateCurrentDistribution();
        autoCalculate();
      });

      // Manejar cambios en el campo ISIN
      let isinTimeout;
      inputMap.isin.addEventListener("input", (e) => {
        const isinValue = inputMap.isin.value.trim().toUpperCase();
        clearTimeout(isinTimeout);

        if (isinValue.length >= 12) {
          // Validar formato ISIN básico (12 caracteres)
          const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;
          if (isinRegex.test(isinValue)) {
            // Mostrar indicador de carga
            inputMap.isin.classList.add("border-blue-500");
            inputMap.price.disabled = true;

            // Capturar los elementos en el closure
            const priceInput = inputMap.price;
            const isinInput = inputMap.isin;

            isinTimeout = setTimeout(() => {
              // Verificar que el valor no haya cambiado
              const currentIsin = isinInput.value.trim().toUpperCase();

              if (currentIsin === isinValue && isinRegex.test(currentIsin)) {
                // Obtener el estado del toggle de unidades completas
                const row = isinInput.closest("[data-row]");
                const wholeToggle = row.querySelector('[data-field="whole"]');
                const isETF =
                  wholeToggle.getAttribute("aria-checked") === "true";

                fetchPriceByISIN(currentIsin, priceInput, isinInput, isETF);
              }
            }, 800); // Debounce de 800ms
          }
        } else {
          inputMap.isin.classList.remove("border-blue-500");
        }

        saveFormState();
      });

      row.querySelectorAll("input").forEach((input) => {
        if (input !== inputMap.isin) {
          input.addEventListener("input", () => {
            window.requestAnimationFrame(updateCurrentDistribution);
            saveFormState();
            autoCalculate();
          });
        }
      });

      // Manejar el botón de eliminar
      const deleteBtn = row.querySelector('[data-action="delete-row"]');
      if (deleteBtn) {
        deleteBtn.addEventListener("click", () => {
          deleteRow(row);
        });
      }
    };

    const initialRows = rowsContainer.querySelectorAll("[data-row]");
    initialRows.forEach((row, index) =>
      initializeRow(row, initialAssets[index] ?? {}),
    );

    const createRow = () => {
      const fragment = rowTemplate.content.cloneNode(true);
      const row = fragment.querySelector("[data-row]");
      rowsContainer.appendChild(fragment);
      initializeRow(row);
      updateCurrentDistribution();
      saveFormState();
    };

    const deleteRow = (row) => {
      const allRows = rowsContainer.querySelectorAll("[data-row]");

      // Si es la única fila, eliminarla y crear una vacía
      if (allRows.length === 1) {
        row.remove();
        createRow();
      } else {
        // Si hay más filas, simplemente eliminar
        row.remove();
      }

      updateCurrentDistribution();
      saveFormState();
      autoCalculate();
    };

    addRowBtn.addEventListener("click", createRow);

    transfersToggle.addEventListener("click", () => {
      const current = transfersEnabled();
      setTransfersToggle(!current);
      saveFormState();
      autoCalculate();
    });

    const getRows = ({ strict = true } = {}) =>
      [...rowsContainer.querySelectorAll("[data-row]")].map((row, index) => {
        const nameField = row.querySelector('[data-field="name"]');
        const isinField = row.querySelector('[data-field="isin"]');
        const currentField = row.querySelector('[data-field="current"]');
        const priceField = row.querySelector('[data-field="price"]');
        const targetField = row.querySelector('[data-field="target"]');
        const wholeToggle = row.querySelector('[data-field="whole"]');
        const includedToggle = row.querySelector('[data-field="included"]');

        const name = nameField.value.trim() || `Activo ${index + 1}`;
        const isin = isinField.value.trim().toUpperCase() || null;
        const current = sanitize(currentField.value);
        const target = sanitize(targetField.value);
        const wholeUnits = wholeToggle.getAttribute("aria-checked") === "true";
        const includedInCalculation =
          includedToggle.getAttribute("aria-checked") === "true";
        const price = wholeUnits
          ? sanitize(priceField.value)
          : sanitize(priceField.value) || 0;

        if (strict) {
          if (current < 0 || target < 0) {
            throw new Error(
              "Los importes y objetivos deben ser iguales o mayores que 0.",
            );
          }

          if (wholeUnits && price <= 0) {
            throw new Error(`Define un precio por unidad válido para ${name}.`);
          }
        }

        return {
          name,
          isin,
          current,
          price: price > 0 ? price : 0,
          target,
          wholeUnits,
          includedInCalculation,
        };
      });

    const updateCurrentDistribution = () => {
      try {
        const rows = getRows({ strict: false });
        const totalAll = rows.reduce((sum, asset) => sum + asset.current, 0);
        const includedRows = rows.filter(
          (asset) => asset.includedInCalculation,
        );
        const totalIncluded = includedRows.reduce(
          (sum, asset) => sum + asset.current,
          0,
        );

        if (totalAll <= 0) {
          currentTotalLabel.textContent = "-";
          currentTotalLabel.dataset.total = "0";
          distributionList.innerHTML =
            '<li class="rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400">Introduce los importes para ver el reparto.</li>';
          return;
        }

        currentTotalLabel.dataset.total = totalAll.toString();

        // Mostrar dos totales: todos y solo incluidos
        if (totalIncluded !== totalAll) {
          currentTotalLabel.innerHTML = `
						<div class="flex flex-col gap-1">
							<span>Total: ${numberFormatter.format(totalAll)}</span>
							<span class="text-sm text-blue-300">Incluidos: ${numberFormatter.format(totalIncluded)}</span>
						</div>
					`;
        } else {
          currentTotalLabel.textContent = numberFormatter.format(totalAll);
        }

        // Mostrar todos los activos, pero marcar visualmente los excluidos
        const allRowElements = Array.from(
          rowsContainer.querySelectorAll("[data-row]"),
        );
        distributionList.innerHTML = rows
          .map((asset, index) => {
            // Obtener el nombre real del campo de la fila correspondiente
            const rowElement = allRowElements[index];
            const nameField = rowElement?.querySelector('[data-field="name"]');
            // Usar el valor del campo si existe, sino el nombre del asset
            const displayName = nameField?.value?.trim() || asset.name;
            const isIncluded = asset.includedInCalculation;
            const opacity = isIncluded ? "" : "opacity-50";
            const totalForPercent = isIncluded ? totalIncluded : totalAll;

            return `
							<li class="flex items-center justify-between rounded-lg border border-gray-700 bg-gray-700/50 px-3 py-2 text-sm ${opacity}">
								<strong class="text-gray-200">${displayName}</strong>
								<span class="font-medium text-blue-400">${percentFormatter.format(asset.current / totalForPercent)}</span>
							</li>
						`;
          })
          .join("");
      } catch (error) {
        // Ignorar errores en modo no estricto
      }
    };

    updateCurrentDistribution();

    const normalizeTargets = (assets, marginFraction) => {
      const sumTargets = assets.reduce((sum, asset) => sum + asset.target, 0);
      if (sumTargets <= 0) {
        throw new Error("La suma de objetivos debe ser mayor que 0 %.");
      }

      return assets.map((asset) => {
        const weight = asset.target / sumTargets;
        const minShare = clamp(weight - marginFraction, 0, 1);
        const maxShare = clamp(weight + marginFraction, 0, 1);
        if (maxShare <= 0 && asset.current > 0) {
          throw new Error(
            `El margen no permite mantener ${asset.name} sin vender.`,
          );
        }
        return { ...asset, weight, minShare, maxShare };
      });
    };

    const projectToBounds = (targets, mins, maxs, total) => {
      const minSum = mins.reduce((sum, value) => sum + value, 0);
      const maxSum = maxs.reduce((sum, value) => sum + value, 0);

      if (total < minSum - 1e-6) {
        throw new Error(
          "El presupuesto disponible es insuficiente para respetar los mínimos dentro del margen.",
        );
      }

      if (total > maxSum + 1e-6) {
        throw new Error(
          "Los objetivos y el margen no permiten usar todo el presupuesto sin sobrepasar límites.",
        );
      }

      const allocations = targets.map((value, index) =>
        clamp(value, mins[index], maxs[index]),
      );

      for (let i = 0; i < 80; i++) {
        const currentTotal = allocations.reduce((sum, value) => sum + value, 0);
        const diff = total - currentTotal;
        if (Math.abs(diff) <= 1e-6) break;

        const freeIndexes = allocations
          .map((value, index) => ({ value, index }))
          .filter(
            (item) =>
              item.value > mins[item.index] + 1e-9 &&
              item.value < maxs[item.index] - 1e-9,
          );

        if (!freeIndexes.length) break;

        const share = diff / freeIndexes.length;
        let adjusted = false;

        freeIndexes.forEach((item) => {
          let candidate = allocations[item.index] + share;
          if (candidate < mins[item.index]) {
            candidate = mins[item.index];
            adjusted = true;
          } else if (candidate > maxs[item.index]) {
            candidate = maxs[item.index];
            adjusted = true;
          }
          allocations[item.index] = candidate;
        });

        if (!adjusted && Math.abs(diff) <= 1e-6) break;
      }

      const finalTotal = allocations.reduce((sum, v) => sum + v, 0);
      if (Math.abs(finalTotal - total) > 1e-4) {
        throw new Error(
          "No se pudo encontrar una distribución válida con las restricciones actuales.",
        );
      }

      return allocations;
    };

    const raiseGroupMinimums = (mins, maxs, groups) => {
      let unresolved = 0;
      groups.forEach((group) => {
        const currentMin = group.indexes.reduce(
          (sum, idx) => sum + mins[idx],
          0,
        );
        let deficit = group.required - currentMin;
        let safety = 0;

        while (deficit > 1e-6) {
          safety += 1;
          if (safety > 50) break;
          const adjustable = group.indexes.filter(
            (idx) => maxs[idx] - mins[idx] > 1e-9,
          );
          if (!adjustable.length) {
            unresolved += deficit;
            break;
          }
          const totalRoom = adjustable.reduce(
            (sum, idx) => sum + (maxs[idx] - mins[idx]),
            0,
          );
          if (totalRoom + 1e-6 < deficit) {
            // Llevar todo a su máximo posible
            adjustable.forEach((idx) => {
              mins[idx] = maxs[idx];
            });
            unresolved += deficit - totalRoom;
            break;
          }

          adjustable.forEach((idx) => {
            const room = maxs[idx] - mins[idx];
            const addition = Math.min(room, (room / totalRoom) * deficit);
            mins[idx] += addition;
          });

          const newMin = group.indexes.reduce((sum, idx) => sum + mins[idx], 0);
          deficit = group.required - newMin;
        }
      });
      return unresolved;
    };

    const computeWithTransfers = (assets, budget) => {
      const marginFraction = getMarginFraction();
      const normalized = normalizeTargets(assets, marginFraction);
      const currentTotal = normalized.reduce(
        (sum, asset) => sum + asset.current,
        0,
      );

      // PASO 1: Calcular asignación solo con traspasos (sin añadir dinero)
      const transferTotal = currentTotal;
      const transferMins = normalized.map(
        (asset) => asset.minShare * transferTotal,
      );
      const transferMaxs = normalized.map(
        (asset) => asset.maxShare * transferTotal,
      );
      const transferTargets = normalized.map(
        (asset) => asset.weight * transferTotal,
      );

      // ETFs no pueden venderse
      normalized.forEach((asset, idx) => {
        if (asset.wholeUnits) {
          transferMins[idx] = Math.max(transferMins[idx], asset.current);
          transferMaxs[idx] = Math.max(transferMaxs[idx], asset.current);
        }
      });

      // Asegurar que maxs >= mins
      normalized.forEach((asset, idx) => {
        transferMaxs[idx] = Math.max(transferMaxs[idx], transferMins[idx]);
      });

      // Verificar factibilidad antes de proyectar
      const transferMinSum = transferMins.reduce((sum, v) => sum + v, 0);
      if (transferMinSum > transferTotal + 1e-6) {
        // Escalar mínimos proporcionalmente
        const scale = transferTotal / transferMinSum;
        normalized.forEach((asset, idx) => {
          transferMins[idx] *= scale;
          transferMaxs[idx] = Math.max(transferMaxs[idx], transferMins[idx]);
        });
      }

      const transferAllocations = projectToBounds(
        transferTargets,
        transferMins,
        transferMaxs,
        transferTotal,
      );

      // Verificar si realmente hay ventas necesarias (algún activo debe reducir su valor)
      const hasSales = normalized.some(
        (asset, idx) => transferAllocations[idx] < asset.current - 1e-6,
      );

      // Si no hay ventas necesarias, usar la misma lógica que allocateWithBudget
      if (!hasSales) {
        return allocateWithBudget(assets, budget);
      }

      // PASO 2: Calcular mínimo dinero adicional necesario
      const calcMinNeeded = () => {
        let low = transferTotal;
        let high = transferTotal * 3;

        const feasible = (total) => {
          try {
            const mins = normalized.map((asset) => asset.minShare * total);
            const maxs = normalized.map((asset) => asset.maxShare * total);
            const targets = normalized.map((asset) => asset.weight * total);

            normalized.forEach((asset, idx) => {
              if (asset.wholeUnits) {
                mins[idx] = Math.max(mins[idx], asset.current);
              } else {
                mins[idx] = Math.max(mins[idx], transferAllocations[idx]);
              }
            });

            // Verificar si los mínimos son factibles
            const minSum = mins.reduce((sum, v) => sum + v, 0);
            if (minSum > total + 1e-6) {
              return false;
            }

            // Asegurar que maxs >= mins
            normalized.forEach((asset, idx) => {
              maxs[idx] = Math.max(maxs[idx], mins[idx]);
            });

            const allocs = projectToBounds(targets, mins, maxs, total);
            const needed = normalized.reduce((sum, asset, idx) => {
              const need = allocs[idx] - transferAllocations[idx];
              return sum + Math.max(0, need);
            }, 0);

            return transferTotal + needed <= total + 1e-6;
          } catch (e) {
            return false;
          }
        };

        for (let i = 0; i < 60; i++) {
          const mid = (low + high) / 2;
          if (feasible(mid)) {
            high = mid;
          } else {
            low = mid;
          }
          if (high - low < 1e-6) break;
        }
        return high;
      };

      const minNeededTotal = calcMinNeeded();
      const minNeededBudget = minNeededTotal - currentTotal;

      // PASO 3: Determinar total final y asignaciones
      let finalTotal;
      let allocations;

      if (budget <= 0) {
        // Sin presupuesto: usar solo traspasos (sin añadir dinero)
        finalTotal = currentTotal;
        allocations = transferAllocations; // Usar directamente las asignaciones de traspasos
      } else {
        // Con presupuesto: combinar traspasos con compras
        // Intentar usar todo el presupuesto disponible
        const candidateTotal = currentTotal + budget;
        // Si el candidato es mayor o igual al mínimo, usarlo
        // De lo contrario, usar el mínimo (pero esto generará un warning)
        finalTotal = Math.max(candidateTotal, minNeededTotal);

        // PASO 4: Calcular asignación final con presupuesto
        const mins = normalized.map((asset) => asset.minShare * finalTotal);
        const maxs = normalized.map((asset) => asset.maxShare * finalTotal);
        const targets = normalized.map((asset) => asset.weight * finalTotal);

        // Establecer mínimos: ETFs no pueden bajar, fondos pueden bajar hasta lo que tienen tras traspasos
        normalized.forEach((asset, idx) => {
          if (asset.wholeUnits) {
            mins[idx] = Math.max(mins[idx], asset.current);
          } else {
            // Fondos pueden vender hasta lo que tienen tras traspasos
            const minFromTransfer = transferAllocations[idx];
            mins[idx] = Math.max(mins[idx], minFromTransfer);
          }
        });

        // Asegurar que la suma de mínimos no exceda el total
        const minSum = mins.reduce((sum, v) => sum + v, 0);
        if (minSum > finalTotal + 1e-6) {
          // Escalar los mínimos de fondos proporcionalmente
          const fixedSum = normalized.reduce(
            (sum, asset, idx) => sum + (asset.wholeUnits ? mins[idx] : 0),
            0,
          );
          const availableForFonds = Math.max(0, finalTotal - fixedSum);
          const fondsMinSum = normalized.reduce(
            (sum, asset, idx) => sum + (!asset.wholeUnits ? mins[idx] : 0),
            0,
          );

          if (fondsMinSum > 1e-6) {
            const scale = availableForFonds / fondsMinSum;
            normalized.forEach((asset, idx) => {
              if (!asset.wholeUnits) {
                mins[idx] *= scale;
              }
            });
          }
        }

        // Asegurar que maxs >= mins
        normalized.forEach((asset, idx) => {
          maxs[idx] = Math.max(maxs[idx], mins[idx]);
        });

        allocations = projectToBounds(targets, mins, maxs, finalTotal);
      }

      const breakdown = normalized.map((asset, index) => {
        const desired = allocations[index];
        let addition = desired - asset.current;

        if (asset.wholeUnits && addition < 0) {
          addition = 0;
        }

        const units = asset.price > 0 ? addition / asset.price : addition;
        return { ...asset, desired, addition, units };
      });

      const buys = breakdown.reduce(
        (sum, asset) => sum + Math.max(0, asset.addition),
        0,
      );
      const sells = breakdown.reduce(
        (sum, asset) => sum + Math.max(0, -asset.addition),
        0,
      );
      const netSpent = buys - sells;

      const providedBudget = budget > 0 ? budget : 0;

      // Calcular cuánto dinero adicional se necesita después de los traspasos
      const additionalNeeded = breakdown.reduce((sum, asset) => {
        // Solo contar compras (addition > 0)
        return sum + Math.max(0, asset.addition);
      }, 0);

      // Si hay presupuesto, el importe realmente usado es el mínimo entre netSpent y el presupuesto
      // Si no hay presupuesto, es 0 (solo traspasos)
      const actualNeeded =
        providedBudget > 0 ? Math.min(netSpent, providedBudget) : 0;
      // El dinero adicional necesario es el que se necesita para las compras
      const extraNeeded =
        budget <= 0 ? additionalNeeded : Math.max(0, netSpent - providedBudget);

      let bestEffort = null;
      let warning = null;

      // Si no hay presupuesto y se necesita dinero adicional después de traspasos
      if (budget <= 0 && extraNeeded > 1e-6) {
        warning = {
          type: "additional_needed",
          message: `Después de realizar los traspasos necesarios, se requiere aportar ${numberFormatter.format(extraNeeded)} adicionales para alcanzar los objetivos dentro del margen.`,
          minRequired: extraNeeded,
        };
      } else if (providedBudget > 0 && extraNeeded > 1e-6) {
        const targetAdds = breakdown.map((asset) => asset.addition || 0);
        const totalNeeded = targetAdds.reduce(
          (sum, val) => sum + Math.max(0, val),
          0,
        );
        const factor =
          totalNeeded > 0 ? Math.min(1, providedBudget / totalNeeded) : 0;

        const bestAlloc = normalized.map((asset, index) => {
          const scaledAdd = Math.max(0, targetAdds[index]) * factor;
          const desired = asset.current + scaledAdd;
          const units = asset.price > 0 ? scaledAdd / asset.price : scaledAdd;
          return {
            ...asset,
            desired,
            addition: scaledAdd,
            units,
          };
        });

        bestEffort = {
          breakdown: bestAlloc,
          invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),
        };

        warning = {
          type: "insufficient",
          message: `El presupuesto indicado (${numberFormatter.format(
            providedBudget,
          )}) es insuficiente. Se necesitan al menos ${numberFormatter.format(
            netSpent,
          )} para alcanzar los mínimos dentro del margen establecido.`,
          minRequired: netSpent,
        };
      }

      return {
        breakdown,
        bestEffort,
        totals: {
          mode: providedBudget > 0 ? "budget" : "transfers",
          currentTotal,
          finalTotal,
          budget: budget <= 0 ? additionalNeeded : providedBudget,
          budgetProvided: providedBudget,
          extraNeeded,
          invested: budget <= 0 ? 0 : netSpent,
          leftover: 0,
          allowTransfers: true,
        },
        warning,
      };
    };

    const ensureOverweightConstraint = (assets, total) =>
      assets.every((asset) => {
        if (asset.maxShare <= 0) {
          return asset.current <= 1e-6;
        }
        return asset.current <= asset.maxShare * total + 1e-6;
      });

    const minimalContribution = (assets) => {
      const marginFraction = getMarginFraction();
      const normalized = normalizeTargets(assets, marginFraction);
      const currentTotal = normalized.reduce(
        (sum, asset) => sum + asset.current,
        0,
      );

      const minTotalFromOverweight = normalized.reduce((max, asset) => {
        if (asset.maxShare <= 0) {
          return asset.current <= 0 ? max : Infinity;
        }
        return Math.max(max, asset.current / asset.maxShare);
      }, currentTotal);

      let low = Math.max(currentTotal, minTotalFromOverweight);
      let high = Number.isFinite(low) ? low : currentTotal + 1;

      const requiredAddition = (total) =>
        normalized.reduce((sum, asset) => {
          const targetValue = asset.minShare * total;
          return sum + Math.max(0, targetValue - asset.current);
        }, 0);

      const feasible = (total) => {
        if (!Number.isFinite(total)) return false;
        if (!ensureOverweightConstraint(normalized, total)) return false;
        const additions = requiredAddition(total);
        return currentTotal + additions <= total + 1e-6;
      };

      if (!feasible(high)) {
        while (!feasible(high)) {
          high *= 2;
          if (high > 1e12) {
            throw new Error(
              "No se puede alcanzar la distribución con el margen indicado.",
            );
          }
        }
      }

      for (let i = 0; i < 60; i++) {
        const mid = (low + high) / 2;
        if (feasible(mid)) {
          high = mid;
        } else {
          low = mid;
        }
      }

      const finalTotal = high;
      const breakdown = normalized.map((asset) => {
        const desired = Math.max(asset.current, asset.minShare * finalTotal);
        const addition = Math.max(0, desired - asset.current);
        const units = asset.price > 0 ? addition / asset.price : 0;
        return { ...asset, desired, addition, units };
      });

      const invested = breakdown.reduce(
        (sum, asset) => sum + asset.addition,
        0,
      );
      return {
        breakdown,
        totals: {
          mode: "minimal",
          currentTotal,
          finalTotal,
          invested,
        },
      };
    };

    const allocateWithBudget = (assets, budget) => {
      const marginFraction = getMarginFraction();
      const normalized = normalizeTargets(assets, marginFraction);
      const currentTotal = normalized.reduce(
        (sum, asset) => sum + asset.current,
        0,
      );
      const finalTotal = currentTotal + budget;

      let warning = null;
      let minimalResult = null;
      let isOverweight = false;

      // Verificar si hay activos sobreponderados
      if (!ensureOverweightConstraint(normalized, finalTotal)) {
        // Calcular el mínimo necesario (lo ideal)
        minimalResult = minimalContribution(assets);
        warning = {
          type: "overweight",
          message: `⚠️ Con el presupuesto actual (${numberFormatter.format(budget)}) algunos activos quedarían sobreponderados. Se necesitarían al menos ${numberFormatter.format(minimalResult.totals.invested)} para mantener el balance dentro del margen.`,
          minRequired: minimalResult.totals.invested,
        };
        isOverweight = true;
      }

      // Calcular límites: si un activo está sobreponderado, no puede crecer ni bajar
      const lowerBounds = normalized.map((asset) => {
        const maxFromMargin = asset.maxShare * finalTotal;
        // Si el activo está sobreponderado, no puede bajar (su mínimo es su valor actual)
        if (asset.current > maxFromMargin + 1e-6) {
          return asset.current;
        }
        return Math.max(asset.current, asset.minShare * finalTotal);
      });
      const upperBounds = normalized.map((asset, index) => {
        const maxFromMargin = asset.maxShare * finalTotal;
        // Si el activo ya está sobreponderado, su máximo es su valor actual
        if (asset.current > maxFromMargin + 1e-6) {
          return asset.current;
        }
        return Math.max(lowerBounds[index], maxFromMargin);
      });

      const sumLower = lowerBounds.reduce((sum, value) => sum + value, 0);
      if (sumLower - finalTotal > 1e-6) {
        const minRequired = sumLower - currentTotal;
        warning = {
          type: "insufficient",
          message: `⚠️ El presupuesto indicado (${numberFormatter.format(budget)}) es insuficiente. Se necesitan al menos ${numberFormatter.format(minRequired)} para alcanzar los mínimos dentro del margen establecido.`,
          minRequired: minRequired,
        };
      }

      let allocations = [...lowerBounds];
      let remaining = finalTotal - sumLower;

      let flex = normalized
        .map((asset, index) => ({
          index,
          capacity: upperBounds[index] - allocations[index],
        }))
        .filter((item) => item.capacity > 1e-6);

      while (flex.length && remaining > 1e-6) {
        const weightSum = flex.reduce(
          (sum, item) => sum + normalized[item.index].weight,
          0,
        );
        if (weightSum <= 0) break;

        let consumed = 0;
        const nextFlex = [];

        flex.forEach((item) => {
          const asset = normalized[item.index];
          const share = (asset.weight / weightSum) * remaining;
          if (share >= item.capacity - 1e-9) {
            allocations[item.index] += item.capacity;
            consumed += item.capacity;
          } else {
            allocations[item.index] += share;
            consumed += share;
            nextFlex.push({
              index: item.index,
              capacity: item.capacity - share,
            });
          }
        });

        if (consumed <= 1e-9) break;
        remaining -= consumed;
        flex = nextFlex;
      }

      const leftover = Math.max(0, remaining);

      const breakdown = normalized.map((asset, index) => {
        const desired = allocations[index];
        const addition = Math.max(0, desired - asset.current);
        const units = asset.price > 0 ? addition / asset.price : 0;
        return { ...asset, desired, addition, units };
      });

      const invested = breakdown.reduce(
        (sum, asset) => sum + asset.addition,
        0,
      );

      let bestEffort = null;
      if (warning && warning.type === "insufficient") {
        const targetAdds = breakdown.map((asset) => asset.addition || 0);
        const totalNeeded = targetAdds.reduce((sum, val) => sum + val, 0);
        const factor = totalNeeded > 0 ? Math.min(1, budget / totalNeeded) : 0;

        const bestAlloc = normalized.map((asset, index) => {
          const scaledAdd = targetAdds[index] * factor;
          const desired = asset.current + scaledAdd;
          const units = asset.price > 0 ? scaledAdd / asset.price : scaledAdd;
          return {
            ...asset,
            desired,
            addition: scaledAdd,
            units,
          };
        });

        bestEffort = {
          breakdown: bestAlloc,
          invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),
        };
      }

      // Si hay sobreponderación, intercambiar breakdown y bestEffort
      // breakdown principal = lo ideal (minimalResult)
      // bestEffort = lo que realmente se puede hacer con el presupuesto disponible
      // (distribuyendo el presupuesto sin exceder los máximos)
      if (isOverweight && minimalResult) {
        // Calcular un bestEffort que respete los límites máximos y use exactamente el presupuesto
        const safeFinalTotal = currentTotal + budget;

        // Límites mínimos: no bajar de lo actual
        const safeMins = normalized.map((asset) => asset.current);

        // Límites máximos: respetar el máximo del margen en el total final
        // Si un activo ya está sobreponderado, su máximo es su valor actual
        const safeMaxs = normalized.map((asset, idx) => {
          const maxFromMargin = asset.maxShare * safeFinalTotal;
          // Si el activo ya está por encima del máximo permitido, no puede crecer
          if (asset.current > maxFromMargin + 1e-6) {
            return asset.current;
          }
          return Math.max(safeMins[idx], maxFromMargin);
        });

        // Empezar desde los mínimos
        let safeAllocations = [...safeMins];
        let remaining = budget;

        // Distribuir el presupuesto respetando los máximos
        let flex = normalized
          .map((asset, index) => ({
            index,
            capacity: safeMaxs[index] - safeAllocations[index],
          }))
          .filter((item) => item.capacity > 1e-6);

        while (flex.length && remaining > 1e-6) {
          const weightSum = flex.reduce(
            (sum, item) => sum + normalized[item.index].weight,
            0,
          );
          if (weightSum <= 0) break;

          let consumed = 0;
          const nextFlex = [];

          flex.forEach((item) => {
            const asset = normalized[item.index];
            const share = (asset.weight / weightSum) * remaining;
            if (share >= item.capacity - 1e-9) {
              safeAllocations[item.index] += item.capacity;
              consumed += item.capacity;
            } else {
              safeAllocations[item.index] += share;
              consumed += share;
              nextFlex.push({
                index: item.index,
                capacity: item.capacity - share,
              });
            }
          });

          if (consumed <= 1e-9) break;
          remaining -= consumed;
          flex = nextFlex;
        }

        const safeBreakdown = normalized.map((asset, index) => {
          const desired = safeAllocations[index];
          const addition = Math.max(0, desired - asset.current);
          const units = asset.price > 0 ? addition / asset.price : 0;
          return { ...asset, desired, addition, units };
        });

        // El presupuesto usado es el total del presupuesto menos el leftover
        const safeInvested = budget - Math.max(0, remaining);

        return {
          breakdown: minimalResult.breakdown,
          bestEffort: {
            breakdown: safeBreakdown,
            invested: safeInvested,
          },
          totals: {
            mode: "budget",
            currentTotal,
            finalTotal: minimalResult.totals.finalTotal,
            budget: minimalResult.totals.invested,
            invested: minimalResult.totals.invested,
            leftover: Math.max(0, remaining),
          },
          warning,
        };
      }

      return {
        breakdown,
        bestEffort,
        totals: {
          mode: "budget",
          currentTotal,
          finalTotal,
          budget,
          invested,
          leftover,
        },
        warning,
      };
    };

    const applyUnitConstraints = (breakdown, totals, allowTransfers) => {
      const targetSpend =
        totals.mode === "budget" ? totals.budget : totals.invested;

      const adjusted = breakdown.map((asset) => {
        let addition = asset.addition;
        let units = asset.price > 0 ? asset.addition / asset.price : 0;

        if (asset.wholeUnits && asset.price > 0) {
          if (addition >= 0) {
            if (totals.mode === "minimal") {
              units = Math.ceil(units - 1e-9);
            } else {
              units = Math.floor(units + 1e-9);
            }
          } else {
            // Ventas: aproximar hacia cero para no sobre-vender
            units = Math.ceil(units - 1e-9);
          }
          addition = units * asset.price;
        }

        return { ...asset, addition, units };
      });

      const buys = adjusted.reduce(
        (sum, asset) => sum + Math.max(0, asset.addition),
        0,
      );
      const sells = adjusted.reduce(
        (sum, asset) => sum + Math.max(0, -asset.addition),
        0,
      );

      const netSpent = adjusted.reduce((sum, asset) => sum + asset.addition, 0);

      // Calcular leftover: cuando hay presupuesto, usar el presupuesto disponible menos lo gastado
      let leftover = 0;
      if (totals.mode === "budget") {
        leftover = Math.max(0, targetSpend - netSpent);
      } else if (allowTransfers && totals.budgetProvided > 0) {
        // Cuando hay traspasos y presupuesto, calcular leftover basado en el presupuesto disponible
        leftover = Math.max(0, totals.budgetProvided - netSpent);
      }

      if (leftover > 0.01) {
        const fractional = adjusted.filter(
          (asset) => !asset.wholeUnits || asset.price <= 0,
        );

        fractional
          .sort(
            (a, b) =>
              b.desired -
              (b.current + b.addition) -
              (a.desired - (a.current + a.addition)),
          )
          .forEach((asset) => {
            if (leftover <= 0.01) return;
            const gap = asset.desired - (asset.current + asset.addition);
            if (gap <= 0) return;
            const delta = Math.min(gap, leftover);
            asset.addition += delta;
            if (asset.price > 0 && !asset.wholeUnits) {
              asset.units = asset.addition / asset.price;
            }
            leftover -= delta;
          });
      }

      const finalSpent = adjusted.reduce(
        (sum, asset) => sum + asset.addition,
        0,
      );
      const finalTotal = totals.currentTotal + finalSpent;

      return {
        breakdown: adjusted.map((asset) => ({
          ...asset,
          finalShare:
            finalTotal > 0 ? (asset.current + asset.addition) / finalTotal : 0,
        })),
        spent: finalSpent,
        leftover,
        finalTotal,
        buys,
        sells,
        net: finalSpent,
      };
    };

    const generateStepGuide = (breakdown, totals, bestApplied) => {
      // Usar bestApplied si existe (aportación real), sino usar breakdown (lo ideal)
      const activeBreakdown =
        bestApplied && bestApplied.breakdown
          ? bestApplied.breakdown
          : breakdown;

      const steps = [];
      let stepNumber = 1;

      // Separar ventas y compras, diferenciando fondos (no wholeUnits) de ETFs (wholeUnits)
      const sales = activeBreakdown
        .filter((asset) => asset.addition < -1e-6)
        .map((asset) => ({
          name: asset.name,
          amount: Math.abs(asset.addition),
          units:
            asset.units && asset.wholeUnits && asset.price > 0
              ? Math.abs(Math.round(asset.units))
              : null,
          price: asset.price,
          wholeUnits: asset.wholeUnits,
        }));

      const purchases = activeBreakdown
        .filter((asset) => asset.addition > 1e-6)
        .map((asset) => ({
          name: asset.name,
          amount: asset.addition,
          units:
            asset.units && asset.wholeUnits && asset.price > 0
              ? Math.round(asset.units)
              : null,
          price: asset.price,
          wholeUnits: asset.wholeUnits,
        }));

      // Separar fondos de ETFs
      const fundSales = sales.filter((s) => !s.wholeUnits);
      const etfSales = sales.filter((s) => s.wholeUnits);
      const fundPurchases = purchases.filter((p) => !p.wholeUnits);
      const etfPurchases = purchases.filter((p) => p.wholeUnits);

      // Calcular totales
      const totalFundSales = fundSales.reduce((sum, s) => sum + s.amount, 0);
      const totalEtfSales = etfSales.reduce((sum, s) => sum + s.amount, 0);
      const totalFundPurchases = fundPurchases.reduce(
        (sum, p) => sum + p.amount,
        0,
      );
      const totalEtfPurchases = etfPurchases.reduce(
        (sum, p) => sum + p.amount,
        0,
      );
      const totalSales = totalFundSales + totalEtfSales;
      const totalPurchases = totalFundPurchases + totalEtfPurchases;
      const netNeeded = totals.allowTransfers
        ? Math.max(0, totalPurchases - totalSales)
        : totalPurchases;

      // Si hay traspasos habilitados, hacer traspasos directos entre fondos
      if (totals.allowTransfers) {
        // Crear traspasos directos entre fondos
        const salesToProcess = fundSales.map((s) => ({ ...s }));
        const purchasesToProcess = fundPurchases.map((p) => ({ ...p }));

        // Emparejar ventas con compras de fondos (traspasos directos)
        while (salesToProcess.length > 0 && purchasesToProcess.length > 0) {
          const sale = salesToProcess[0];
          const purchase = purchasesToProcess[0];

          const transferAmount = Math.min(sale.amount, purchase.amount);

          // Solo añadir paso si el importe es significativo
          if (transferAmount > 0.01) {
            steps.push({
              text: `<strong>${stepNumber}. Traspasa ${numberFormatter.format(transferAmount)} </strong> | <strong>${sale.name}</strong> → <strong>${purchase.name}</strong>`,
              type: "transfer",
            });
            stepNumber++;
          }

          // Actualizar montos restantes
          sale.amount -= transferAmount;
          purchase.amount -= transferAmount;

          if (sale.amount < 1e-6) {
            salesToProcess.shift();
          }
          if (purchase.amount < 1e-6) {
            purchasesToProcess.shift();
          }
        }

        // Si quedan ventas de fondos, seguir emparejándolas con las compras restantes
        while (salesToProcess.length > 0 && purchasesToProcess.length > 0) {
          const sale = salesToProcess[0];
          const purchase = purchasesToProcess[0];

          const transferAmount = Math.min(sale.amount, purchase.amount);

          // Solo añadir paso si el importe es significativo
          if (transferAmount > 0.01) {
            steps.push({
              text: `<strong>${stepNumber}. Traspasa ${numberFormatter.format(transferAmount)} </strong> | <strong>${sale.name}</strong> → <strong>${purchase.name}</strong>`,
              type: "transfer",
            });
            stepNumber++;
          }

          sale.amount -= transferAmount;
          purchase.amount -= transferAmount;

          if (sale.amount < 1e-6) {
            salesToProcess.shift();
          }
          if (purchase.amount < 1e-6) {
            purchasesToProcess.shift();
          }
        }

        // ETFs: vender primero (no se pueden traspasar, solo vender/comprar)
        etfSales.forEach((sale) => {
          steps.push({
            text: `<strong>${stepNumber}. Vende ${numberFormatter.format(sale.amount)} </strong> | <strong>${sale.name}</strong>`,
            type: "transfer",
          });
          stepNumber++;
        });

        // Si hay dinero adicional necesario después de los traspasos
        if (netNeeded > 1e-6) {
          steps.push({
            text: `<strong>${stepNumber}. Aporta ${numberFormatter.format(netNeeded)} adicionales para completar las compras</strong>`,
            type: "contribution",
          });
          stepNumber++;
        }

        // Compras de fondos que no fueron cubiertas por traspasos
        purchasesToProcess.forEach((purchase) => {
          if (purchase.amount > 1e-6) {
            steps.push({
              text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,
              type: "purchase",
            });
            stepNumber++;
          }
        });

        // Compras de ETFs
        etfPurchases.forEach((purchase) => {
          steps.push({
            text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,
            type: "purchase",
          });
          stepNumber++;
        });
      } else {
        // Sin traspasos, mostrar primero la aportación necesaria
        if (netNeeded > 1e-6) {
          steps.push({
            text: `<strong>${stepNumber}. Aporta ${numberFormatter.format(netNeeded)}</strong>`,
            type: "contribution",
          });
          stepNumber++;
        }

        // Mostrar las compras
        purchases.forEach((purchase) => {
          steps.push({
            text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,
            type: "purchase",
          });
          stepNumber++;
        });
      }

      // Si no hay acciones
      if (steps.length === 0) {
        steps.push({
          text: "<strong>1. No se requieren acciones. Tu cartera ya cumple con los objetivos dentro del margen establecido.</strong>",
          type: "info",
        });
      }

      // Mostrar leftover si existe
      if (totals.leftover > 0.01) {
        steps.push({
          text: `<strong>Nota:</strong> Quedan ${numberFormatter.format(totals.leftover)} sin asignar debido a restricciones de unidades completas.`,
          type: "info",
        });
      }

      return steps;
    };

    const renderResults = (breakdown, totals, bestApplied) => {
      const summaryItems = [
        {
          label: "Total actual",
          value: numberFormatter.format(totals.currentTotal),
        },
        {
          label: "Total tras inversión",
          value: numberFormatter.format(totals.finalTotal),
        },
        {
          label: totals.allowTransfers
            ? "Importe neto (compras - ventas)"
            : totals.mode === "budget"
              ? "Importe a invertir"
              : "Mínimo a invertir",
          value: numberFormatter.format(totals.invested),
        },
      ];

      if (totals.mode === "budget") {
        const budgetItems = [
          {
            label: "Presupuesto calculado",
            value: numberFormatter.format(totals.budget),
          },
        ];

        if (
          totals.allowTransfers &&
          typeof totals.budgetProvided !== "undefined"
        ) {
          budgetItems.push({
            label: "Presupuesto indicado",
            value: numberFormatter.format(totals.budgetProvided),
          });
        }

        if (totals.allowTransfers && totals.extraNeeded > 0.01) {
          budgetItems.push({
            label: "Extra para evitar cruzar tipos",
            value: numberFormatter.format(totals.extraNeeded),
          });
        }

        summaryItems.push(...budgetItems);

        if (totals.leftover > 0.01) {
          summaryItems.push({
            label: "Sobrante sin asignar",
            value: numberFormatter.format(totals.leftover),
          });
        }
      }

      if (
        totals.allowTransfers &&
        totals.mode !== "budget" &&
        totals.extraNeeded > 0.01
      ) {
        summaryItems.push({
          label: "Extra necesario para rebalancear por tipos",
          value: numberFormatter.format(totals.extraNeeded),
        });
      }

      if (totals.allowTransfers && totals.sells > 0.01) {
        summaryItems.push(
          {
            label: "Compras estimadas",
            value: numberFormatter.format(totals.buys),
          },
          {
            label: "Ventas estimadas",
            value: numberFormatter.format(totals.sells),
          },
        );
      }

      summaryItems.push({
        label: "Margen aplicado",
        value: `${marginNumberFormatter.format(getMarginValue())} %`,
      });

      summaryEl.innerHTML = summaryItems
        .map(
          (item) => `
				<div class="rounded-lg border border-gray-700 bg-gray-800/70 p-3 sm:p-4">
					<div class="text-xs text-gray-400 sm:text-sm">${item.label}</div>
					<div class="mt-1 text-lg font-bold text-gray-100 sm:text-xl">${item.value}</div>
				</div>`,
        )
        .join("");

      tbody.innerHTML = "";
      breakdown.forEach((asset, index) => {
        const row = document.createElement("tr");
        row.className = index % 2 === 0 ? "bg-gray-800/50" : "bg-gray-900/50";

        const bestAsset =
          bestApplied && bestApplied.breakdown
            ? bestApplied.breakdown[index]
            : null;

        const unitsLabel =
          asset.price > 0
            ? asset.wholeUnits
              ? `${asset.units.toFixed(0)} ud`
              : unitFormatter.format(asset.units)
            : "—";
        const additionClass =
          asset.addition > 0
            ? "text-green-400"
            : asset.addition < 0
              ? "text-red-400"
              : "text-gray-300";

        const bestAddition =
          bestAsset && typeof bestAsset.addition === "number"
            ? bestAsset.addition
            : null;
        const bestClass =
          bestAddition === null
            ? ""
            : bestAddition > 0
              ? "text-green-400"
              : bestAddition < 0
                ? "text-red-400"
                : "text-gray-300";
        const bestUnitsLabel =
          bestAsset && bestAsset.price > 0
            ? bestAsset.wholeUnits
              ? `${bestAsset.units.toFixed(0)} ud`
              : unitFormatter.format(bestAsset.units)
            : bestAsset
              ? "—"
              : null;

        row.innerHTML = `
					<td class="px-3 py-2 text-xs text-gray-200 sm:px-4 sm:py-3 sm:text-sm">${asset.name}</td>
					<td class="px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm">${numberFormatter.format(asset.current)}</td>
					<td class="px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm">${numberFormatter.format(asset.desired)}</td>
					<td class="px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm ${additionClass}">${numberFormatter.format(
            asset.addition,
          )}</td>
					<td class="px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm ${bestClass}">${
            bestAsset ? numberFormatter.format(bestAddition) : "—"
          }</td>
					<td class="px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm">${unitsLabel}</td>
					<td class="px-3 py-2 text-xs font-medium text-blue-400 sm:px-4 sm:py-3 sm:text-sm">${percentFormatter.format(asset.finalShare)}</td>
				`;
        tbody.appendChild(row);
      });

      const positiveAssets = breakdown.filter((asset) => asset.addition > 0);
      const negativeAssets = breakdown.filter((asset) => asset.addition < 0);

      if (!positiveAssets.length) {
        if (totals.allowTransfers && negativeAssets.length) {
          const sellAsset = negativeAssets.reduce((prev, current) =>
            -current.addition > -prev.addition ? current : prev,
          );
          adviceEl.textContent = `Solo necesitas traspasos: reduce ${sellAsset.name} en ${numberFormatter.format(
            Math.abs(sellAsset.addition),
          )} y redistribuye según la tabla.`;
        } else {
          adviceEl.textContent =
            "Ya cumples la distribución objetivo; no es necesario aportar más.";
        }
        return;
      }

      const maxAsset = positiveAssets.reduce((prev, current) =>
        current.addition > prev.addition ? current : prev,
      );

      const baseMessage =
        totals.mode === "budget"
          ? `Con el presupuesto indicado empieza por ${maxAsset.name}, requiere ${numberFormatter.format(
              maxAsset.addition,
            )}.`
          : `Para alcanzar la distribución dentro del margen aporta primero en ${maxAsset.name}, necesita ${numberFormatter.format(
              maxAsset.addition,
            )}.`;

      const leftoverMessage =
        totals.mode === "budget" && totals.leftover > 0.01
          ? ` Quedarán ${numberFormatter.format(
              totals.leftover,
            )} libres al no poder comprar fracciones.`
          : "";

      adviceEl.textContent = `${baseMessage}${leftoverMessage}`;

      // Generar y mostrar guía paso a paso
      const steps = generateStepGuide(breakdown, totals, bestApplied);
      if (steps.length > 0) {
        stepList.innerHTML = steps
          .map((step) => {
            let borderColor = "border-gray-700";
            let bgColor = "bg-gray-700/30";

            if (step.type === "transfer") {
              // Naranja para traspasos
              borderColor = "border-orange-500/50";
              bgColor = "bg-orange-600/10";
            } else if (step.type === "purchase") {
              // Verde para compras
              borderColor = "border-green-500/50";
              bgColor = "bg-green-950/30";
            } else if (step.type === "contribution") {
              // Gris para aportaciones
              borderColor = "border-gray-600/50";
              bgColor = "bg-gray-700/30";
            } else if (step.type === "info") {
              // Vainilla/beige para notas
              borderColor = "border-yellow-200/30";
              bgColor = "bg-yellow-50/10";
            }

            return `<li class="rounded-lg border ${borderColor} ${bgColor} p-3">${step.text}</li>`;
          })
          .join("");
        stepGuide.hidden = false;
      } else {
        stepGuide.hidden = true;
      }
    };

    const showError = (message) => {
      errorBox.textContent = message;
      errorBox.hidden = false;
      resultsSection.hidden = true;
    };

    const clearError = () => {
      errorBox.hidden = true;
      errorBox.textContent = "";
    };

    const showWarning = (warning) => {
      if (warning) {
        errorBox.innerHTML = warning.message;
        errorBox.hidden = false;
      } else {
        clearError();
      }
    };

    // Guardar estado en localStorage
    const saveFormState = () => {
      try {
        const rows = getRows({ strict: false });
        const state = {
          budget: budgetInput.value,
          margin: marginInput.value,
          allowTransfers: transfersEnabled(),
          assets: rows.map((row) => ({
            name: row.name,
            isin: row.isin,
            current: row.current,
            price: row.price,
            target: row.target,
            wholeUnits: row.wholeUnits,
            includedInCalculation: row.includedInCalculation,
          })),
        };
        localStorage.setItem(
          "investmentCalculatorState",
          JSON.stringify(state),
        );
      } catch (e) {
        console.warn("No se pudo guardar el estado:", e);
      }
    };

    // Cargar estado desde localStorage
    const loadFormState = () => {
      try {
        const saved = localStorage.getItem("investmentCalculatorState");
        if (saved) {
          const state = JSON.parse(saved);

          // Cargar budget y margin
          if (state.budget !== undefined) budgetInput.value = state.budget;
          if (state.margin !== undefined) marginInput.value = state.margin;
          if (typeof state.allowTransfers !== "undefined") {
            setTransfersToggle(Boolean(state.allowTransfers));
          }

          // Limpiar y recrear filas
          if (state.assets && state.assets.length > 0) {
            rowsContainer.innerHTML = "";
            state.assets.forEach((asset) => {
              const fragment = rowTemplate.content.cloneNode(true);
              const row = fragment.querySelector("[data-row]");
              rowsContainer.appendChild(fragment);
              initializeRow(row, asset);
            });
          }

          updateCurrentDistribution();
          autoCalculate();
        }
      } catch (e) {
        console.warn("No se pudo cargar el estado:", e);
      }
    };

    // Auto-calcular
    let autoCalculateTimeout;
    const autoCalculate = () => {
      clearTimeout(autoCalculateTimeout);
      autoCalculateTimeout = setTimeout(() => {
        try {
          const allRows = getRows();
          // Filtrar solo los activos incluidos en el cálculo
          const rows = allRows.filter((asset) => asset.includedInCalculation);

          if (rows.length === 0) {
            showError("Debe haber al menos un activo incluido en el cálculo");
            return;
          }

          const budget = Math.max(0, sanitize(budgetInput.value));
          const allowMove = transfersEnabled();
          const result = allowMove
            ? computeWithTransfers(rows, budget)
            : budget > 0
              ? allocateWithBudget(rows, budget)
              : minimalContribution(rows);

          // Verificar si realmente hay ventas/traspasos en el resultado
          // Si no hay ventas, tratar como si no hubiera traspasos habilitados
          const hasActualTransfers =
            allowMove &&
            result.breakdown.some((asset) => asset.addition < -1e-6);

          const appliedMain = applyUnitConstraints(
            result.breakdown,
            result.totals,
            hasActualTransfers,
          );

          let appliedBest = null;
          if (result.bestEffort) {
            const bestTotals = {
              ...result.totals,
              invested: result.bestEffort.invested,
              budget,
            };
            appliedBest = applyUnitConstraints(
              result.bestEffort.breakdown,
              bestTotals,
              hasActualTransfers,
            );
          }

          const totals = {
            ...result.totals,
            invested: hasActualTransfers ? appliedMain.net : appliedMain.spent,
            leftover: appliedMain.leftover,
            finalTotal: appliedMain.finalTotal,
            buys: appliedMain.buys,
            sells: appliedMain.sells,
            allowTransfers: hasActualTransfers,
            bestEffort: appliedBest,
          };

          resultsSection.hidden = false;
          renderResults(appliedMain.breakdown, totals, appliedBest);

          // Mostrar warning si existe
          if (result.warning) {
            showWarning(result.warning);
          } else {
            clearError();
          }
        } catch (err) {
          showError(err.message);
        }
      }, 500);
    };

    // Event listeners para inputs principales
    budgetInput.addEventListener("input", () => {
      saveFormState();
      autoCalculate();
    });

    marginInput.addEventListener("input", () => {
      saveFormState();
      autoCalculate();
    });

    // Prevenir submit del form
    form.addEventListener("submit", (event) => {
      event.preventDefault();
    });

    // Exportar datos a JSON
    const exportData = () => {
      try {
        const rows = getRows({ strict: false });
        const data = {
          version: "1.0",
          budget: budgetInput.value || "",
          margin: marginInput.value || "",
          allowTransfers: transfersEnabled(),
          assets: rows.map((row) => ({
            name: row.name,
            isin: row.isin || "",
            current: row.current,
            price: row.price || "",
            target: row.target,
            wholeUnits: row.wholeUnits,
            includedInCalculation: row.includedInCalculation,
          })),
        };

        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `calculadora-inversion-${new Date().toISOString().split("T")[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        showError("Error al exportar los datos: " + error.message);
      }
    };

    // Importar datos desde JSON
    const importData = (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          if (!data.assets || !Array.isArray(data.assets)) {
            throw new Error("Formato de archivo inválido");
          }

          // Cargar presupuesto y margen
          if (data.budget !== undefined) budgetInput.value = data.budget || "";
          if (data.margin !== undefined) marginInput.value = data.margin || "";
          if (typeof data.allowTransfers !== "undefined") {
            setTransfersToggle(Boolean(data.allowTransfers));
          }

          // Limpiar y recrear filas
          rowsContainer.innerHTML = "";
          data.assets.forEach((asset) => {
            const fragment = rowTemplate.content.cloneNode(true);
            const row = fragment.querySelector("[data-row]");
            rowsContainer.appendChild(fragment);
            initializeRow(row, {
              name: asset.name || "",
              isin: asset.isin || null,
              current: asset.current || null,
              price: asset.price || null,
              target: asset.target || 0,
              wholeUnits: Boolean(asset.wholeUnits),
              includedInCalculation:
                typeof asset.includedInCalculation === "undefined"
                  ? true
                  : Boolean(asset.includedInCalculation),
            });
          });

          // Si no hay activos, crear uno vacío
          if (data.assets.length === 0) {
            const fragment = rowTemplate.content.cloneNode(true);
            const row = fragment.querySelector("[data-row]");
            rowsContainer.appendChild(fragment);
            initializeRow(row);
          }

          updateCurrentDistribution();
          saveFormState();
          autoCalculate();
          clearError();

          // Refrescar precios de todos los ISINs
          setTimeout(() => refreshAllPrices(), 500);
        } catch (error) {
          showError("Error al importar los datos: " + error.message);
        }
      };
      reader.onerror = () => {
        showError("Error al leer el archivo");
      };
      reader.readAsText(file);
    };

    exportBtn.addEventListener("click", exportData);

    importBtn.addEventListener("click", () => {
      importFileInput.click();
    });

    importFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) {
        if (file.type !== "application/json" && !file.name.endsWith(".json")) {
          showError("El archivo debe ser un JSON válido");
          return;
        }
        importData(file);
        // Limpiar el input para permitir cargar el mismo archivo de nuevo
        e.target.value = "";
      }
    });

    resetBtn.addEventListener("click", () => {
      // Limpiar localStorage
      localStorage.removeItem("investmentCalculatorState");

      form.reset();
      setTransfersToggle(false);
      rowsContainer.innerHTML = "";
      initialAssets.forEach((asset) => {
        const fragment = rowTemplate.content.cloneNode(true);
        const row = fragment.querySelector("[data-row]");
        rowsContainer.appendChild(fragment);
        initializeRow(row, asset);
      });
      resultsSection.hidden = true;
      clearError();
      updateCurrentDistribution();
      saveFormState();
      autoCalculate();
    });

    // Cargar estado inicial al cargar la página
    loadFormState();

    // Refrescar precios de todos los ISINs después de cargar
    setTimeout(() => refreshAllPrices(), 1000);

    // ==========================================
    // HORIZON CALCULATOR
    // ==========================================
    (() => {
      const toggle = document.getElementById("horizon-toggle");
      const panel = document.getElementById("horizon-panel");
      const chevron = document.getElementById("horizon-chevron");
      const monthlyInput = document.getElementById("hz-monthly");
      const targetInput = document.getElementById("hz-target");
      const monthsInput = document.getElementById("hz-months");
      const dateInput = document.getElementById("hz-date");
      const initialInput = document.getElementById("hz-initial");
      const rvPctInput = document.getElementById("hz-rv-pct");
      const rvLabel = document.getElementById("hz-rv-label");
      const rvModeToggle = document.getElementById("hz-rv-mode-toggle");
      const rvTaeInput = document.getElementById("hz-rv-tae");
      const rfTaeInput = document.getElementById("hz-rf-tae");

      // RV mode: 'pct' or 'eur'
      let rvMode = "pct";

      rvModeToggle.addEventListener("click", (e) => {
        e.preventDefault();
        if (rvMode === "pct") {
          rvMode = "eur";
          rvLabel.textContent = "Renta variable (€)";
          rvModeToggle.textContent = "Cambiar a %";
          rvPctInput.removeAttribute("max");
          rvPctInput.placeholder = "Ej. 350";
          rvPctInput.value = "";
        } else {
          rvMode = "pct";
          rvLabel.textContent = "Renta variable (%)";
          rvModeToggle.innerHTML = "Cambiar a &euro;";
          rvPctInput.setAttribute("max", "100");
          rvPctInput.placeholder = "";
          rvPctInput.value = "70";
        }
        saveHzState();
        recalc();
      });
      const calcIndicator = document.getElementById("hz-calc-indicator");
      const resultsDiv = document.getElementById("hz-results");
      const summaryDiv = document.getElementById("hz-summary");
      const tableBody = document.getElementById("hz-table-body");
      const canvas = document.getElementById("hz-chart");
      const legendDiv = document.getElementById("hz-chart-legend");
      const errorDiv = document.getElementById("hz-error");

      const fmt = (v) => numberFormatter.format(v);
      const fmtPct = (v) => percentFormatter.format(v);

      // Use current total button
      const useCurrentBtn = document.getElementById("hz-use-current");
      useCurrentBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const total = parseFloat(currentTotalLabel.dataset.total) || 0;
        if (total > 0) {
          initialInput.value = Math.round(total);
          recalc();
        }
      });

      // Toggle panel
      let panelOpen = false;
      toggle.addEventListener("click", () => {
        panelOpen = !panelOpen;
        panel.classList.toggle("hidden", !panelOpen);
        chevron.style.transform = panelOpen ? "rotate(180deg)" : "";
      });

      // Sync date ↔ months
      dateInput.addEventListener("input", () => {
        if (dateInput.value) {
          const [y, m] = dateInput.value.split("-").map(Number);
          const now = new Date();
          const target = new Date(y, m - 1, 1);
          const diffMs =
            target - new Date(now.getFullYear(), now.getMonth(), 1);
          const diffMonths = Math.max(
            1,
            Math.round(diffMs / (1000 * 60 * 60 * 24 * 30.44)),
          );
          monthsInput.value = diffMonths;
        }
        recalc();
      });

      monthsInput.addEventListener("input", () => {
        dateInput.value = "";
        recalc();
      });

      [
        monthlyInput,
        targetInput,
        initialInput,
        rvPctInput,
        rvTaeInput,
        rfTaeInput,
      ].forEach((el) => {
        el.addEventListener("input", recalc);
      });

      // Save / restore horizon state
      const saveHzState = () => {
        const state = {
          monthly: monthlyInput.value,
          target: targetInput.value,
          months: monthsInput.value,
          date: dateInput.value,
          initial: initialInput.value,
          rvPct: rvPctInput.value,
          rvMode: rvMode,
          rvTae: rvTaeInput.value,
          rfTae: rfTaeInput.value,
          open: panelOpen,
        };
        localStorage.setItem("horizonCalcState", JSON.stringify(state));
      };

      const loadHzState = () => {
        try {
          const raw = localStorage.getItem("horizonCalcState");
          if (!raw) return;
          const s = JSON.parse(raw);
          if (s.monthly) monthlyInput.value = s.monthly;
          if (s.target) targetInput.value = s.target;
          if (s.months) monthsInput.value = s.months;
          if (s.date) dateInput.value = s.date;
          if (s.initial) initialInput.value = s.initial;
          if (s.rvPct !== undefined) rvPctInput.value = s.rvPct;
          if (s.rvMode === "eur") {
            rvMode = "eur";
            rvLabel.textContent = "Renta variable (€)";
            rvModeToggle.textContent = "Cambiar a %";
            rvPctInput.removeAttribute("max");
            rvPctInput.placeholder = "Ej. 350";
          }
          if (s.rvTae !== undefined) rvTaeInput.value = s.rvTae;
          if (s.rfTae !== undefined) rfTaeInput.value = s.rfTae;
          if (s.open) {
            panelOpen = true;
            panel.classList.remove("hidden");
            chevron.style.transform = "rotate(180deg)";
          }
        } catch (_) {}
      };

      function recalc() {
        saveHzState();
        errorDiv.classList.add("hidden");
        calcIndicator.classList.add("hidden");
        resultsDiv.classList.add("hidden");

        const monthly = parseFloat(monthlyInput.value) || 0;
        const target = parseFloat(targetInput.value) || 0;
        const months = parseInt(monthsInput.value) || 0;
        const initial = parseFloat(initialInput.value) || 0;
        let rvPct;
        if (rvMode === "eur") {
          const rvEur = parseFloat(rvPctInput.value) || 0;
          rvPct = monthly > 0 ? clamp(rvEur / monthly, 0, 1) : 0;
        } else {
          rvPct = clamp((parseFloat(rvPctInput.value) || 0) / 100, 0, 1);
        }
        const rfPct = 1 - rvPct;
        const rvTaeAnnual = (parseFloat(rvTaeInput.value) || 0) / 100;
        const rfTaeAnnual = (parseFloat(rfTaeInput.value) || 0) / 100;
        const rvMonthly = Math.pow(1 + rvTaeAnnual, 1 / 12) - 1;
        const rfMonthly = Math.pow(1 + rfTaeAnnual, 1 / 12) - 1;

        // Determine which 2 of 3 are filled
        const hasMonthly = monthlyInput.value !== "" && monthly > 0;
        const hasTarget = targetInput.value !== "" && target > 0;
        const hasMonths =
          (monthsInput.value !== "" && months > 0) || dateInput.value !== "";

        const filledCount = [hasMonthly, hasTarget, hasMonths].filter(
          Boolean,
        ).length;

        if (filledCount < 2) {
          if (filledCount === 0) return;
          calcIndicator.classList.remove("hidden");
          calcIndicator.textContent =
            "⏳ Rellena al menos 2 de los 3 campos (inversión mensual, dinero objetivo, horizonte temporal) para calcular.";
          return;
        }

        let calcMonths = months;
        let calcMonthly = monthly;
        let calcTarget = target;
        let mode = "";

        if (hasMonthly && hasMonths && !hasTarget) {
          // Calculate target amount
          mode = "target";
          calcTarget = simulateForward(
            initial,
            calcMonthly,
            calcMonths,
            rvPct,
            rfPct,
            rvMonthly,
            rfMonthly,
          ).total;
          targetInput.value = Math.round(calcTarget);
        } else if (hasTarget && hasMonthly && !hasMonths) {
          // Calculate months needed
          mode = "months";
          calcMonths = solveForMonths(
            initial,
            calcMonthly,
            calcTarget,
            rvPct,
            rfPct,
            rvMonthly,
            rfMonthly,
          );
          if (calcMonths === null) {
            showHzError(
              "Con esta inversión mensual y estas rentabilidades no se alcanza el objetivo (la aportación no compensa).",
            );
            return;
          }
          monthsInput.value = calcMonths;
          const targetDate = new Date();
          targetDate.setMonth(targetDate.getMonth() + calcMonths);
          dateInput.value = targetDate.toISOString().slice(0, 7);
        } else if (hasTarget && hasMonths && !hasMonthly) {
          // Calculate monthly investment needed
          mode = "monthly";
          calcMonthly = solveForMonthly(
            initial,
            calcTarget,
            calcMonths,
            rvPct,
            rfPct,
            rvMonthly,
            rfMonthly,
          );
          if (calcMonthly === null || calcMonthly < 0) {
            // Could be that initial capital + growth already covers it
            calcMonthly = 0;
          }
          monthlyInput.value = Math.round(calcMonthly);
        } else {
          // All 3 filled — use monthly + months to project, show comparison
          mode = "target";
          calcTarget = simulateForward(
            initial,
            calcMonthly,
            calcMonths,
            rvPct,
            rfPct,
            rvMonthly,
            rfMonthly,
          ).total;
        }

        // Now simulate the full progression month by month
        const data = simulateFullProgression(
          initial,
          calcMonthly,
          calcMonths,
          rvPct,
          rfPct,
          rvMonthly,
          rfMonthly,
        );

        // Show indicator
        calcIndicator.classList.remove("hidden");
        if (mode === "target") {
          calcIndicator.innerHTML = `📊 <strong>Calculado:</strong> Con ${fmt(calcMonthly)}/mes durante ${calcMonths} meses (${(calcMonths / 12).toFixed(1)} años), acumularás <strong>${fmt(data.total)}</strong>`;
        } else if (mode === "months") {
          const years = (calcMonths / 12).toFixed(1);
          const targetDate = new Date();
          targetDate.setMonth(targetDate.getMonth() + calcMonths);
          const dateStr = targetDate.toLocaleDateString("es-ES", {
            month: "long",
            year: "numeric",
          });
          calcIndicator.innerHTML = `⏱️ <strong>Calculado:</strong> Necesitas <strong>${calcMonths} meses</strong> (${years} años, ~${dateStr}) para alcanzar ${fmt(calcTarget)}`;
        } else if (mode === "monthly") {
          calcIndicator.innerHTML = `💰 <strong>Calculado:</strong> Necesitas invertir <strong>${fmt(calcMonthly)}/mes</strong> para alcanzar ${fmt(calcTarget)} en ${calcMonths} meses (${(calcMonths / 12).toFixed(1)} años)`;
        }

        renderHzResults(
          data,
          calcMonthly,
          calcMonths,
          calcTarget,
          rvPct,
          rfPct,
          rvTaeAnnual,
          rfTaeAnnual,
        );
      }

      function simulateForward(
        initial,
        monthly,
        months,
        rvPct,
        rfPct,
        rvMonthly,
        rfMonthly,
      ) {
        let rv = initial * rvPct;
        let rf = initial * rfPct;
        for (let i = 0; i < months; i++) {
          rv = rv * (1 + rvMonthly) + monthly * rvPct;
          rf = rf * (1 + rfMonthly) + monthly * rfPct;
        }
        return { rv, rf, total: rv + rf };
      }

      function simulateFullProgression(
        initial,
        monthly,
        months,
        rvPct,
        rfPct,
        rvMonthly,
        rfMonthly,
      ) {
        const points = []; // one per month
        let rv = initial * rvPct;
        let rf = initial * rfPct;
        let invested = initial;

        points.push({
          month: 0,
          invested,
          rv,
          rf,
          total: rv + rf,
          gain: 0,
          gainPct: 0,
        });

        for (let i = 1; i <= months; i++) {
          rv = rv * (1 + rvMonthly) + monthly * rvPct;
          rf = rf * (1 + rfMonthly) + monthly * rfPct;
          invested += monthly;
          const total = rv + rf;
          const gain = total - invested;
          const gainPct = invested > 0 ? gain / invested : 0;
          points.push({ month: i, invested, rv, rf, total, gain, gainPct });
        }

        const last = points[points.length - 1];
        return {
          points,
          total: last.total,
          invested: last.invested,
          gain: last.gain,
          gainPct: last.gainPct,
          rv: last.rv,
          rf: last.rf,
        };
      }

      function solveForMonths(
        initial,
        monthly,
        target,
        rvPct,
        rfPct,
        rvMonthly,
        rfMonthly,
      ) {
        // Iterative approach (compound interest with contributions has no clean closed form for mixed rates)
        let rv = initial * rvPct;
        let rf = initial * rfPct;
        let months = 0;
        const maxMonths = 1200; // 100 years max
        while (rv + rf < target && months < maxMonths) {
          rv = rv * (1 + rvMonthly) + monthly * rvPct;
          rf = rf * (1 + rfMonthly) + monthly * rfPct;
          months++;
        }
        return months >= maxMonths ? null : months;
      }

      function solveForMonthly(
        initial,
        target,
        months,
        rvPct,
        rfPct,
        rvMonthly,
        rfMonthly,
      ) {
        // Binary search for the monthly contribution needed
        let lo = 0,
          hi = target;
        for (let iter = 0; iter < 100; iter++) {
          const mid = (lo + hi) / 2;
          const result = simulateForward(
            initial,
            mid,
            months,
            rvPct,
            rfPct,
            rvMonthly,
            rfMonthly,
          );
          if (result.total < target) {
            lo = mid;
          } else {
            hi = mid;
          }
        }
        return Math.ceil((lo + hi) / 2);
      }

      function showHzError(msg) {
        errorDiv.textContent = msg;
        errorDiv.classList.remove("hidden");
      }

      function renderHzResults(
        data,
        monthly,
        months,
        target,
        rvPct,
        rfPct,
        rvTaeAnnual,
        rfTaeAnnual,
      ) {
        resultsDiv.classList.remove("hidden");

        // Summary cards
        const cards = [
          {
            label: "Total acumulado",
            value: fmt(data.total),
            color: "text-purple-300",
          },
          {
            label: "Total invertido",
            value: fmt(data.invested),
            color: "text-gray-300",
          },
          {
            label: "Ganancia total",
            value: fmt(data.gain),
            color: "text-emerald-400",
          },
          {
            label: "% Ganancia",
            value: fmtPct(data.gainPct),
            color: "text-emerald-400",
          },
          {
            label: "Renta variable",
            value: fmt(data.rv),
            color: "text-green-400",
          },
          { label: "Renta fija", value: fmt(data.rf), color: "text-blue-400" },
        ];
        summaryDiv.innerHTML = cards
          .map(
            (c) =>
              `<div class="rounded-lg border border-gray-700 bg-gray-900 p-3 text-center">
						<p class="text-xs text-gray-400">${c.label}</p>
						<p class="text-lg font-bold ${c.color}">${c.value}</p>
					</div>`,
          )
          .join("");

        // Yearly table
        tableBody.innerHTML = "";
        const yearlyPoints = data.points.filter(
          (p) => p.month % 12 === 0 || p.month === months,
        );
        // Always include final month
        const seen = new Set();
        const displayPoints = [];
        for (const p of yearlyPoints) {
          if (!seen.has(p.month)) {
            seen.add(p.month);
            displayPoints.push(p);
          }
        }
        // Include final if not already
        const last = data.points[data.points.length - 1];
        if (!seen.has(last.month)) displayPoints.push(last);

        for (const p of displayPoints) {
          const yearLabel =
            p.month === 0
              ? "Inicio"
              : p.month % 12 === 0
                ? `Año ${p.month / 12}`
                : `Mes ${p.month}`;
          const gainClass = p.gain >= 0 ? "text-emerald-400" : "text-red-400";
          const row = document.createElement("tr");
          row.className =
            p.month === last.month ? "bg-purple-950/20 font-semibold" : "";
          row.innerHTML = `
						<td class="px-3 py-2 text-gray-300">${yearLabel}</td>
						<td class="px-3 py-2 text-right text-gray-300">${fmt(p.invested)}</td>
						<td class="px-3 py-2 text-right text-green-400">${fmt(p.rv)}</td>
						<td class="px-3 py-2 text-right text-blue-400">${fmt(p.rf)}</td>
						<td class="px-3 py-2 text-right text-gray-100">${fmt(p.total)}</td>
						<td class="px-3 py-2 text-right ${gainClass}">${fmt(p.gain)}</td>
						<td class="px-3 py-2 text-right ${gainClass}">${p.invested > 0 ? fmtPct(p.gainPct) : "-"}</td>
					`;
          tableBody.appendChild(row);
        }

        // Draw chart
        drawChart(data.points, months);
      }

      function drawChart(points, totalMonths) {
        const ctx = canvas.getContext("2d");
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";
        ctx.scale(dpr, dpr);

        // Margins
        const ml = 70,
          mr = 20,
          mt = 20,
          mb = 40;
        const cw = W - ml - mr;
        const ch = H - mt - mb;

        // Clear
        ctx.clearRect(0, 0, W, H);

        // Max value
        const maxVal = Math.max(
          ...points.map((p) => Math.max(p.total, p.invested, p.rv, p.rf)),
        );
        const yMax = maxVal * 1.1 || 100;

        // Helpers
        const xPos = (month) => ml + (month / totalMonths) * cw;
        const yPos = (val) => mt + ch - (val / yMax) * ch;

        // Grid lines
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 0.5;
        const gridLines = 5;
        ctx.font = "11px system-ui, sans-serif";
        ctx.fillStyle = "#9CA3AF";
        ctx.textAlign = "right";
        for (let i = 0; i <= gridLines; i++) {
          const val = (yMax / gridLines) * i;
          const y = yPos(val);
          ctx.beginPath();
          ctx.moveTo(ml, y);
          ctx.lineTo(W - mr, y);
          ctx.stroke();
          // Label
          const label =
            val >= 1000000
              ? (val / 1000000).toFixed(1) + "M"
              : val >= 1000
                ? (val / 1000).toFixed(0) + "K"
                : val.toFixed(0);
          ctx.fillText(label + "€", ml - 8, y + 4);
        }

        // X-axis labels
        ctx.textAlign = "center";
        ctx.fillStyle = "#9CA3AF";
        const xLabels = Math.min(10, totalMonths / 12);
        const step = Math.max(1, Math.floor(totalMonths / 12 / xLabels));
        for (let yr = 0; yr <= totalMonths / 12; yr += step) {
          const m = yr * 12;
          if (m > totalMonths) break;
          ctx.fillText(yr === 0 ? "Inicio" : `Año ${yr}`, xPos(m), H - mb + 20);
        }

        // Sample points for drawing (limit to ~200 points for performance)
        const sampleStep = Math.max(1, Math.floor(points.length / 200));
        const sampled = points.filter(
          (_, i) => i % sampleStep === 0 || i === points.length - 1,
        );

        // Draw filled areas (stacked: invested at bottom, then rf, then rv on top)
        // Area: Total (rv + rf)
        drawArea(
          ctx,
          sampled,
          totalMonths,
          yMax,
          ml,
          mt,
          cw,
          ch,
          (p) => p.total,
          "rgba(168, 85, 247, 0.15)",
        );
        // Area: Invested
        drawArea(
          ctx,
          sampled,
          totalMonths,
          yMax,
          ml,
          mt,
          cw,
          ch,
          (p) => p.invested,
          "rgba(156, 163, 175, 0.12)",
        );

        // Lines
        const series = [
          { key: (p) => p.invested, color: "#9CA3AF", label: "Invertido" },
          { key: (p) => p.rf, color: "#60A5FA", label: "Renta fija" },
          { key: (p) => p.rv, color: "#4ADE80", label: "Renta variable" },
          { key: (p) => p.total, color: "#A855F7", label: "Total" },
          {
            key: (p) => p.gain,
            color: "#34D399",
            label: "Ganancia",
            dashed: true,
          },
        ];

        for (const s of series) {
          ctx.beginPath();
          ctx.strokeStyle = s.color;
          ctx.lineWidth = s.dashed ? 1.5 : 2;
          if (s.dashed) ctx.setLineDash([6, 3]);
          else ctx.setLineDash([]);
          for (let i = 0; i < sampled.length; i++) {
            const x = xPos(sampled[i].month);
            const y = yPos(Math.max(0, s.key(sampled[i])));
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Legend
        legendDiv.innerHTML = series
          .map(
            (s) =>
              `<span class="flex items-center gap-1.5">
						<span class="inline-block h-3 w-3 rounded-sm" style="background:${s.color};${s.dashed ? "opacity:0.6" : ""}"></span>
						${s.label}
					</span>`,
          )
          .join("");
      }

      function drawArea(
        ctx,
        sampled,
        totalMonths,
        yMax,
        ml,
        mt,
        cw,
        ch,
        valFn,
        color,
      ) {
        const xPos = (month) => ml + (month / totalMonths) * cw;
        const yPos = (val) => mt + ch - (val / yMax) * ch;
        ctx.beginPath();
        ctx.moveTo(xPos(sampled[0].month), yPos(0));
        for (const p of sampled) {
          ctx.lineTo(xPos(p.month), yPos(Math.max(0, valFn(p))));
        }
        ctx.lineTo(xPos(sampled[sampled.length - 1].month), yPos(0));
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }

      // Init
      loadHzState();
      recalc();
    })();
  </script>
</BasicLayout>

<style>
  button {
    cursor: pointer;
  }
</style>
