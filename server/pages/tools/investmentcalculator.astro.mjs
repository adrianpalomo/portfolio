import { d as createAstro, c as createComponent, r as renderComponent, a as renderTemplate, f as defineScriptVars, b as addAttribute, m as maybeRenderHead } from '../../chunks/astro/server_y9OgIksR.mjs';
import 'piccolore';
import { $ as $$BasicLayout } from '../../chunks/BasicLayout_D5R6hG-t.mjs';
/* empty css                                                   */
export { renderers } from '../../renderers.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Astro = createAstro("https://adrianpalomo.com");
const $$InvestmentCalculator = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$InvestmentCalculator;
  const defaultAssets = [
    {
      id: "msci",
      name: "MSCI World",
      current: null,
      price: null,
      isin: null,
      target: 60,
      wholeUnits: false
    },
    {
      id: "emergentes",
      name: "Mercados emergentes",
      current: null,
      price: null,
      isin: null,
      target: 10,
      wholeUnits: false
    },
    {
      id: "btc",
      name: "BTC",
      current: null,
      price: null,
      isin: null,
      target: 15,
      wholeUnits: true
    },
    {
      id: "oro",
      name: "Oro",
      current: null,
      price: null,
      isin: null,
      target: 15,
      wholeUnits: true
    }
  ];
  return renderTemplate`${renderComponent($$result, "BasicLayout", $$BasicLayout, { "title": "Calculadora de Inversi\xF3n | Adrian Palomo", "data-astro-cid-4w4x4o4c": true }, { "default": async ($$result2) => renderTemplate(_a || (_a = __template([" ", '<div class="min-h-screen bg-gray-900 px-3 py-4 font-sans text-gray-100 sm:px-4 md:px-6 lg:px-8" data-astro-cid-4w4x4o4c> <h1 class="mb-4 text-2xl font-bold text-blue-500 sm:mb-6 sm:text-3xl" data-astro-cid-4w4x4o4c>\nCalculadora de Inversi\xF3n\n</h1> <div class="mx-auto w-full" data-astro-cid-4w4x4o4c> <div class="mb-4 rounded-lg border border-gray-700 bg-gray-800 p-4 shadow-lg sm:mb-6 sm:p-6" data-astro-cid-4w4x4o4c> <div class="mb-4" data-astro-cid-4w4x4o4c> <p class="text-sm text-gray-300 sm:text-base" data-astro-cid-4w4x4o4c>\nAjusta los pesos objetivo, define si puedes comprar\n						fracciones y establece un presupuesto y un margen de\n						tolerancia para evitar rebalanceos excesivos.\n</p> </div> <form id="allocation-form" novalidate data-astro-cid-4w4x4o4c> <div class="mb-4 grid grid-cols-1 gap-3 sm:mb-6 sm:gap-4 md:grid-cols-2" data-astro-cid-4w4x4o4c> <div class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4" data-astro-cid-4w4x4o4c> <div class="mb-2 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between" data-astro-cid-4w4x4o4c> <label for="budget" class="block text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nDinero disponible (&euro;)\n</label> <div class="flex items-center gap-2" data-astro-cid-4w4x4o4c> <span class="text-xs text-gray-400 sm:text-sm" data-astro-cid-4w4x4o4c>Permitir traspasos</span> <button type="button" id="allow-transfers" role="switch" aria-checked="false" aria-label="Permitir ventas para rebalancear" class="relative inline-flex h-7 w-12 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-5 w-5 translate-x-1 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> </div> <input id="budget" name="budget" type="number" min="0" step="0.01" placeholder="Ej. 500" class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> <small class="mt-2 block text-xs text-blue-400" data-astro-cid-4w4x4o4c>\nD\xE9jalo vac\xEDo para obtener la aportaci\xF3n m\xEDnima\n								sin l\xEDmite.\n</small> </div> <div class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4" data-astro-cid-4w4x4o4c> <label for="margin" class="mb-2 block text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nMargen de error (+/- %)\n</label> <input id="margin" name="margin" type="number" min="0" max="20" step="0.1" value="1" class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> <small class="mt-2 block text-xs text-blue-400" data-astro-cid-4w4x4o4c>\nEvita perseguir el porcentaje exacto; permite\n								una banda segura.\n</small> </div> </div> <div class="mb-4 rounded-lg border border-gray-700 bg-gray-800/50 p-4 sm:mb-6 sm:p-5" data-astro-cid-4w4x4o4c> <div class="mb-3 flex flex-col gap-2 sm:mb-4 sm:flex-row sm:items-center sm:justify-between" data-astro-cid-4w4x4o4c> <h2 class="text-lg font-semibold text-gray-100 sm:text-xl" data-astro-cid-4w4x4o4c>\nReparto actual\n</h2> <span id="current-total-label" class="text-base font-bold text-blue-400 sm:text-lg" data-astro-cid-4w4x4o4c>-</span> </div> <ul id="current-distribution" class="grid grid-cols-1 gap-2 sm:grid-cols-2 lg:grid-cols-3" data-astro-cid-4w4x4o4c> <li class="rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400" data-astro-cid-4w4x4o4c>\nIntroduce los valores actuales para ver el\n								reparto porcentual.\n</li> </ul> </div> <div class="mb-4 space-y-3 sm:mb-6 sm:space-y-4" id="rows-container" data-astro-cid-4w4x4o4c> ', ' </div> <button type="button" id="add-row-btn" class="mb-3 rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:mb-4 sm:px-6" data-astro-cid-4w4x4o4c>\n+ A\xF1adir activo\n</button> <p class="mb-4 text-sm text-gray-400" data-astro-cid-4w4x4o4c>\nActiva el toggle cuando solo puedas comprar unidades\n						completas; el campo de precio se habilitar\xE1\n						autom\xE1ticamente. Los c\xE1lculos se actualizan en tiempo\n						real.\n</p> <div class="flex flex-wrap gap-2" data-astro-cid-4w4x4o4c> <button id="reset-btn" type="button" class="rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nRestablecer\n</button> <button id="export-btn" type="button" class="rounded-md border border-blue-600 bg-blue-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-blue-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nExportar\n</button> <button id="import-btn" type="button" class="rounded-md border border-green-600 bg-green-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-green-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nImportar\n</button> <input type="file" id="import-file" accept=".json" class="hidden" data-astro-cid-4w4x4o4c> </div> <template id="row-template" data-astro-cid-4w4x4o4c> <div class="relative rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-md sm:p-4" data-row data-astro-cid-4w4x4o4c> <button type="button" data-action="delete-row" class="absolute top-2 right-2 rounded-md p-1.5 text-gray-400 transition-colors hover:bg-red-600/20 hover:text-red-400 focus:ring-2 focus:ring-red-500 focus:outline-none" title="Eliminar activo" data-astro-cid-4w4x4o4c> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" data-astro-cid-4w4x4o4c> <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" data-astro-cid-4w4x4o4c></path> </svg> </button> <div class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-8" data-astro-cid-4w4x4o4c> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nISIN\n</label> <input data-field="isin" type="text" placeholder="ES0123456789" class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2 lg:col-span-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nActivo\n</label> <input data-field="name" type="text" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nValor actual (&euro;)\n</label> <input data-field="current" type="number" min="0" step="0.01" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-price-wrapper data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nPrecio unidad (&euro;)\n</label> <input data-field="price" type="number" min="0" step="0.01" disabled class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\n\xBFSolo unidades completas?\n</label> <button type="button" role="switch" data-field="whole" aria-checked="false" aria-label="Activar unidades completas" class="relative inline-flex h-8 w-14 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-6 w-6 translate-x-1 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nObjetivo (%)\n</label> <input data-field="target" type="number" min="0" max="100" step="0.1" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nIncluir en c\xE1lculo\n</label> <button type="button" role="switch" data-field="included" aria-checked="true" aria-label="Incluir en el c\xE1lculo" class="relative inline-flex h-8 w-14 items-center rounded-full bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-6 w-6 translate-x-7 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> </div> </div> </template> </form> <div id="results" class="mt-4 space-y-4 sm:mt-6 sm:space-y-6" hidden data-astro-cid-4w4x4o4c> <div id="summary" class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-3" data-astro-cid-4w4x4o4c></div> <p id="advice" class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-3 text-sm text-gray-200 sm:p-4 sm:text-base" data-astro-cid-4w4x4o4c></p> <div class="overflow-x-auto rounded-lg border border-gray-700 bg-gray-800" data-astro-cid-4w4x4o4c> <table class="w-full" data-astro-cid-4w4x4o4c> <thead class="border-b border-gray-700 bg-gray-900" data-astro-cid-4w4x4o4c> <tr data-astro-cid-4w4x4o4c> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Activo</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Actual</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Objetivo</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Aportar</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>\nTu aportaci\xF3n\n</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Unid.</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>% final</th> </tr> </thead> <tbody id="results-body" class="divide-y divide-gray-700" data-astro-cid-4w4x4o4c></tbody> </table> </div> <div id="step-guide" class="rounded-lg border border-gray-700 bg-gray-800 p-4 sm:p-6" data-astro-cid-4w4x4o4c> <h3 class="mb-4 text-lg font-semibold text-gray-100 sm:text-xl" data-astro-cid-4w4x4o4c>\nPaso a paso\n</h3> <ol id="step-list" class="space-y-3 text-sm text-gray-300 sm:text-base" data-astro-cid-4w4x4o4c></ol> </div> </div> <p id="error" class="mt-4 rounded-lg border border-red-500/50 bg-red-950/30 p-3 text-sm text-red-400 sm:mt-6 sm:p-4" role="alert" hidden data-astro-cid-4w4x4o4c></p> </div> </div> </div> <script type="module">', "\n		const initialAssets = defaultAssets;\n		const form = document.querySelector('#allocation-form');\n		const rowsContainer = document.querySelector('#rows-container');\n		const rowTemplate = document.querySelector('#row-template');\n		const addRowBtn = document.querySelector('#add-row-btn');\n		const budgetInput = document.querySelector('#budget');\n		const marginInput = document.querySelector('#margin');\n		const transfersToggle = document.querySelector('#allow-transfers');\n		const distributionList = document.querySelector(\n			'#current-distribution'\n		);\n		const currentTotalLabel = document.querySelector(\n			'#current-total-label'\n		);\n		const resultsSection = document.querySelector('#results');\n		const summaryEl = document.querySelector('#summary');\n		const adviceEl = document.querySelector('#advice');\n		const tbody = document.querySelector('#results-body');\n		const stepGuide = document.querySelector('#step-guide');\n		const stepList = document.querySelector('#step-list');\n		const errorBox = document.querySelector('#error');\n		const resetBtn = document.querySelector('#reset-btn');\n		const exportBtn = document.querySelector('#export-btn');\n		const importBtn = document.querySelector('#import-btn');\n		const importFileInput = document.querySelector('#import-file');\n\n		const numberFormatter = new Intl.NumberFormat('es-ES', {\n			style: 'currency',\n			currency: 'EUR',\n			minimumFractionDigits: 2,\n		});\n\n		const percentFormatter = new Intl.NumberFormat('es-ES', {\n			style: 'percent',\n			minimumFractionDigits: 2,\n			maximumFractionDigits: 2,\n		});\n\n		const unitFormatter = new Intl.NumberFormat('es-ES', {\n			minimumFractionDigits: 2,\n			maximumFractionDigits: 4,\n		});\n\n		const marginNumberFormatter = new Intl.NumberFormat('es-ES', {\n			minimumFractionDigits: 0,\n			maximumFractionDigits: 2,\n		});\n\n		const clamp = (value, min = 0, max = 1) =>\n			Math.min(Math.max(value, min), max);\n\n		const sanitize = (value) => {\n			if (typeof value !== 'string') return 0;\n			return Number(value.replace(',', '.')) || 0;\n		};\n\n		// Funci\xF3n para refrescar todos los precios de ISINs en el formulario\n		const refreshAllPrices = () => {\n			const rows = rowsContainer.querySelectorAll('[data-row]');\n			rows.forEach((row) => {\n				const isinInput = row.querySelector('[data-field=\"isin\"]');\n				const priceInput = row.querySelector('[data-field=\"price\"]');\n				const wholeToggle = row.querySelector('[data-field=\"whole\"]');\n\n				const isin = isinInput?.value?.trim().toUpperCase();\n				const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;\n\n				// Solo intentar si hay un ISIN v\xE1lido\n				if (\n					isin &&\n					isinRegex.test(isin) &&\n					isinInput &&\n					priceInput &&\n					wholeToggle\n				) {\n					const isETF =\n						wholeToggle.getAttribute('aria-checked') === 'true';\n					// A\xF1adir un peque\xF1o delay entre requests para no sobrecargar\n					setTimeout(() => {\n						fetchPriceByISIN(isin, priceInput, isinInput, isETF);\n					}, Math.random() * 1000); // Random delay 0-1s\n				}\n			});\n		};\n\n		// Funci\xF3n para obtener el precio de un fondo por ISIN\n		const fetchPriceByISIN = async (isin, priceInput, isinInput, isETF) => {\n			// Validar que el ISIN no est\xE9 vac\xEDo\n			if (!isin || isin.trim().length === 0) {\n				console.warn('ISIN vac\xEDo o inv\xE1lido:', isin);\n				return;\n			}\n\n			// Mostrar estado de carga\n			isinInput.classList.remove('border-yellow-500', 'border-green-500');\n			isinInput.classList.add('border-blue-500');\n			isinInput.title = 'Buscando precio...';\n\n			try {\n				// Normalizar ISIN antes de enviarlo\n				const normalizedIsin = isin.trim().toUpperCase();\n\n				// Construir URL con query params\n				const params = new URLSearchParams();\n				params.set('isin', normalizedIsin);\n				params.set('isETF', isETF ? 'true' : 'false');\n				const apiUrl = `/api/fund-price?${params.toString()}`;\n\n				// Llamar al endpoint API de Astro que hace el fetch desde el servidor\n				// Esto evita problemas de CORS mediante web scraping\n				const response = await fetch(apiUrl, {\n					method: 'GET',\n					headers: {\n						Accept: 'application/json',\n					},\n				});\n\n				if (!response.ok) {\n					const errorData = await response.json().catch(() => ({}));\n					throw new Error(\n						errorData.message || 'No se pudo obtener el precio'\n					);\n				}\n\n				const data = await response.json();\n\n				if (data.price && data.price > 0) {\n					// Precio obtenido exitosamente\n					priceInput.value = data.price.toFixed(4);\n\n					// Actualizar el nombre si viene en la respuesta\n					if (data.name) {\n						const row = priceInput.closest('[data-row]');\n						const nameInput = row.querySelector(\n							'[data-field=\"name\"]'\n						);\n						// Solo actualizar si est\xE1 vac\xEDo o es un nombre gen\xE9rico\n						if (\n							!nameInput.value ||\n							nameInput.value.startsWith('Activo ')\n						) {\n							nameInput.value = data.name;\n						}\n					}\n\n					// Habilitar el campo de precio si el toggle est\xE1 activado\n					const row = priceInput.closest('[data-row]');\n					const wholeToggle = row.querySelector(\n						'[data-field=\"whole\"]'\n					);\n					if (wholeToggle.getAttribute('aria-checked') === 'true') {\n						priceInput.disabled = false;\n					}\n\n					// Actualizar estilos\n					isinInput.classList.remove('border-blue-500');\n					isinInput.classList.add('border-green-500');\n					isinInput.title = 'Precio obtenido correctamente';\n\n					// Actualizar c\xE1lculos\n					saveFormState();\n					updateCurrentDistribution();\n					autoCalculate();\n				} else {\n					throw new Error(data.message || 'Precio no disponible');\n				}\n			} catch (error) {\n				// Si falla, mostrar mensaje al usuario\n				console.warn('Error al obtener precio por ISIN:', error);\n\n				isinInput.classList.remove('border-blue-500');\n				isinInput.classList.add('border-yellow-500');\n				isinInput.title =\n					'No se pudo obtener el precio autom\xE1ticamente. Introd\xFAcelo manualmente en el campo \"Precio unidad\".';\n\n				// Habilitar el campo de precio para entrada manual si el toggle est\xE1 activado\n				const row = priceInput.closest('[data-row]');\n				const wholeToggle = row.querySelector('[data-field=\"whole\"]');\n				if (wholeToggle.getAttribute('aria-checked') === 'true') {\n					priceInput.disabled = false;\n					priceInput.focus();\n				}\n			}\n		};\n\n		const getMarginValue = () => {\n			const raw = marginInput.value.trim();\n			const fallback = raw === '' ? 1 : sanitize(raw);\n			return Math.max(0, fallback);\n		};\n\n		const getMarginFraction = () => getMarginValue() / 100;\n\n		const setTransfersToggle = (enabled) => {\n			const state = Boolean(enabled);\n			transfersToggle.setAttribute('aria-checked', state);\n			if (state) {\n				transfersToggle.classList.remove('bg-gray-600');\n				transfersToggle.classList.add('bg-blue-600');\n				transfersToggle\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				transfersToggle\n					.querySelector('span')\n					.classList.add('translate-x-6');\n			} else {\n				transfersToggle.classList.remove('bg-blue-600');\n				transfersToggle.classList.add('bg-gray-600');\n				transfersToggle\n					.querySelector('span')\n					.classList.remove('translate-x-6');\n				transfersToggle\n					.querySelector('span')\n					.classList.add('translate-x-1');\n			}\n		};\n\n		const transfersEnabled = () =>\n			transfersToggle.getAttribute('aria-checked') === 'true';\n\n		const initializeRow = (row, data = {}) => {\n			const inputMap = {\n				name: row.querySelector('[data-field=\"name\"]'),\n				isin: row.querySelector('[data-field=\"isin\"]'),\n				current: row.querySelector('[data-field=\"current\"]'),\n				price: row.querySelector('[data-field=\"price\"]'),\n				target: row.querySelector('[data-field=\"target\"]'),\n				whole: row.querySelector('[data-field=\"whole\"]'),\n				included: row.querySelector('[data-field=\"included\"]'),\n			};\n\n			if (data.name) inputMap.name.value = data.name;\n			if (data.isin) inputMap.isin.value = data.isin;\n			if (typeof data.current !== 'undefined')\n				inputMap.current.value = data.current;\n			if (typeof data.price !== 'undefined' && data.price !== 0)\n				inputMap.price.value = data.price;\n			if (typeof data.target !== 'undefined')\n				inputMap.target.value = data.target;\n\n			// Inicializar estado del toggle de unidades completas\n			const isChecked = Boolean(data.wholeUnits);\n			inputMap.whole.setAttribute('aria-checked', isChecked);\n			if (isChecked) {\n				inputMap.whole.classList.remove('bg-gray-600');\n				inputMap.whole.classList.add('bg-blue-600');\n				inputMap.whole\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				inputMap.whole\n					.querySelector('span')\n					.classList.add('translate-x-7');\n			}\n\n			// Inicializar estado del toggle de inclusi\xF3n en c\xE1lculo\n			const isIncluded =\n				typeof data.includedInCalculation === 'undefined'\n					? true\n					: Boolean(data.includedInCalculation);\n			inputMap.included.setAttribute('aria-checked', isIncluded);\n			if (isIncluded) {\n				inputMap.included.classList.remove('bg-gray-600');\n				inputMap.included.classList.add('bg-blue-600');\n				inputMap.included\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				inputMap.included\n					.querySelector('span')\n					.classList.add('translate-x-7');\n			} else {\n				inputMap.included.classList.remove('bg-blue-600');\n				inputMap.included.classList.add('bg-gray-600');\n				inputMap.included\n					.querySelector('span')\n					.classList.remove('translate-x-7');\n				inputMap.included\n					.querySelector('span')\n					.classList.add('translate-x-1');\n			}\n\n			const updatePriceState = () => {\n				const enabled =\n					inputMap.whole.getAttribute('aria-checked') === 'true';\n				inputMap.price.disabled = !enabled;\n				inputMap.price.required = enabled;\n			};\n\n			// Manejar click en el toggle\n			inputMap.whole.addEventListener('click', () => {\n				const isChecked =\n					inputMap.whole.getAttribute('aria-checked') === 'true';\n				const newState = !isChecked;\n\n				inputMap.whole.setAttribute('aria-checked', newState);\n				if (newState) {\n					inputMap.whole.classList.remove('bg-gray-600');\n					inputMap.whole.classList.add('bg-blue-600');\n					inputMap.whole\n						.querySelector('span')\n						.classList.remove('translate-x-1');\n					inputMap.whole\n						.querySelector('span')\n						.classList.add('translate-x-7');\n				} else {\n					inputMap.whole.classList.remove('bg-blue-600');\n					inputMap.whole.classList.add('bg-gray-600');\n					inputMap.whole\n						.querySelector('span')\n						.classList.remove('translate-x-7');\n					inputMap.whole\n						.querySelector('span')\n						.classList.add('translate-x-1');\n				}\n\n				updatePriceState();\n				saveFormState();\n				autoCalculate();\n			});\n\n			updatePriceState();\n\n			// Manejar click en el toggle de inclusi\xF3n\n			inputMap.included.addEventListener('click', () => {\n				const isChecked =\n					inputMap.included.getAttribute('aria-checked') === 'true';\n				const newState = !isChecked;\n\n				inputMap.included.setAttribute('aria-checked', newState);\n				if (newState) {\n					inputMap.included.classList.remove('bg-gray-600');\n					inputMap.included.classList.add('bg-blue-600');\n					inputMap.included\n						.querySelector('span')\n						.classList.remove('translate-x-1');\n					inputMap.included\n						.querySelector('span')\n						.classList.add('translate-x-7');\n				} else {\n					inputMap.included.classList.remove('bg-blue-600');\n					inputMap.included.classList.add('bg-gray-600');\n					inputMap.included\n						.querySelector('span')\n						.classList.remove('translate-x-7');\n					inputMap.included\n						.querySelector('span')\n						.classList.add('translate-x-1');\n				}\n\n				saveFormState();\n				updateCurrentDistribution();\n				autoCalculate();\n			});\n\n			// Manejar cambios en el campo ISIN\n			let isinTimeout;\n			inputMap.isin.addEventListener('input', (e) => {\n				const isinValue = inputMap.isin.value.trim().toUpperCase();\n				clearTimeout(isinTimeout);\n\n				if (isinValue.length >= 12) {\n					// Validar formato ISIN b\xE1sico (12 caracteres)\n					const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;\n					if (isinRegex.test(isinValue)) {\n						// Mostrar indicador de carga\n						inputMap.isin.classList.add('border-blue-500');\n						inputMap.price.disabled = true;\n\n						// Capturar los elementos en el closure\n						const priceInput = inputMap.price;\n						const isinInput = inputMap.isin;\n\n						isinTimeout = setTimeout(() => {\n							// Verificar que el valor no haya cambiado\n							const currentIsin = isinInput.value\n								.trim()\n								.toUpperCase();\n\n							if (\n								currentIsin === isinValue &&\n								isinRegex.test(currentIsin)\n							) {\n								// Obtener el estado del toggle de unidades completas\n								const row = isinInput.closest('[data-row]');\n								const wholeToggle = row.querySelector(\n									'[data-field=\"whole\"]'\n								);\n								const isETF =\n									wholeToggle.getAttribute('aria-checked') ===\n									'true';\n\n								fetchPriceByISIN(\n									currentIsin,\n									priceInput,\n									isinInput,\n									isETF\n								);\n							}\n						}, 800); // Debounce de 800ms\n					}\n				} else {\n					inputMap.isin.classList.remove('border-blue-500');\n				}\n\n				saveFormState();\n			});\n\n			row.querySelectorAll('input').forEach((input) => {\n				if (input !== inputMap.isin) {\n					input.addEventListener('input', () => {\n						window.requestAnimationFrame(updateCurrentDistribution);\n						saveFormState();\n						autoCalculate();\n					});\n				}\n			});\n\n			// Manejar el bot\xF3n de eliminar\n			const deleteBtn = row.querySelector('[data-action=\"delete-row\"]');\n			if (deleteBtn) {\n				deleteBtn.addEventListener('click', () => {\n					deleteRow(row);\n				});\n			}\n		};\n\n		const initialRows = rowsContainer.querySelectorAll('[data-row]');\n		initialRows.forEach((row, index) =>\n			initializeRow(row, initialAssets[index] ?? {})\n		);\n\n		const createRow = () => {\n			const fragment = rowTemplate.content.cloneNode(true);\n			const row = fragment.querySelector('[data-row]');\n			rowsContainer.appendChild(fragment);\n			initializeRow(row);\n			updateCurrentDistribution();\n			saveFormState();\n		};\n\n		const deleteRow = (row) => {\n			const allRows = rowsContainer.querySelectorAll('[data-row]');\n\n			// Si es la \xFAnica fila, eliminarla y crear una vac\xEDa\n			if (allRows.length === 1) {\n				row.remove();\n				createRow();\n			} else {\n				// Si hay m\xE1s filas, simplemente eliminar\n				row.remove();\n			}\n\n			updateCurrentDistribution();\n			saveFormState();\n			autoCalculate();\n		};\n\n		addRowBtn.addEventListener('click', createRow);\n\n		transfersToggle.addEventListener('click', () => {\n			const current = transfersEnabled();\n			setTransfersToggle(!current);\n			saveFormState();\n			autoCalculate();\n		});\n\n		const getRows = ({ strict = true } = {}) =>\n			[...rowsContainer.querySelectorAll('[data-row]')].map(\n				(row, index) => {\n					const nameField = row.querySelector('[data-field=\"name\"]');\n					const isinField = row.querySelector('[data-field=\"isin\"]');\n					const currentField = row.querySelector(\n						'[data-field=\"current\"]'\n					);\n					const priceField = row.querySelector(\n						'[data-field=\"price\"]'\n					);\n					const targetField = row.querySelector(\n						'[data-field=\"target\"]'\n					);\n					const wholeToggle = row.querySelector(\n						'[data-field=\"whole\"]'\n					);\n					const includedToggle = row.querySelector(\n						'[data-field=\"included\"]'\n					);\n\n					const name =\n						nameField.value.trim() || `Activo ${index + 1}`;\n					const isin = isinField.value.trim().toUpperCase() || null;\n					const current = sanitize(currentField.value);\n					const target = sanitize(targetField.value);\n					const wholeUnits =\n						wholeToggle.getAttribute('aria-checked') === 'true';\n					const includedInCalculation =\n						includedToggle.getAttribute('aria-checked') === 'true';\n					const price = wholeUnits\n						? sanitize(priceField.value)\n						: sanitize(priceField.value) || 0;\n\n					if (strict) {\n						if (current < 0 || target < 0) {\n							throw new Error(\n								'Los importes y objetivos deben ser iguales o mayores que 0.'\n							);\n						}\n\n						if (wholeUnits && price <= 0) {\n							throw new Error(\n								`Define un precio por unidad v\xE1lido para ${name}.`\n							);\n						}\n					}\n\n					return {\n						name,\n						isin,\n						current,\n						price: price > 0 ? price : 0,\n						target,\n						wholeUnits,\n						includedInCalculation,\n					};\n				}\n			);\n\n		const updateCurrentDistribution = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const totalAll = rows.reduce(\n					(sum, asset) => sum + asset.current,\n					0\n				);\n				const includedRows = rows.filter(\n					(asset) => asset.includedInCalculation\n				);\n				const totalIncluded = includedRows.reduce(\n					(sum, asset) => sum + asset.current,\n					0\n				);\n\n				if (totalAll <= 0) {\n					currentTotalLabel.textContent = '-';\n					distributionList.innerHTML =\n						'<li class=\"rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400\">Introduce los importes para ver el reparto.</li>';\n					return;\n				}\n\n				// Mostrar dos totales: todos y solo incluidos\n				if (totalIncluded !== totalAll) {\n					currentTotalLabel.innerHTML = `\n						<div class=\"flex flex-col gap-1\">\n							<span>Total: ${numberFormatter.format(totalAll)}</span>\n							<span class=\"text-sm text-blue-300\">Incluidos: ${numberFormatter.format(totalIncluded)}</span>\n						</div>\n					`;\n				} else {\n					currentTotalLabel.textContent =\n						numberFormatter.format(totalAll);\n				}\n\n				// Mostrar todos los activos, pero marcar visualmente los excluidos\n				const allRowElements = Array.from(\n					rowsContainer.querySelectorAll('[data-row]')\n				);\n				distributionList.innerHTML = rows\n					.map((asset, index) => {\n						// Obtener el nombre real del campo de la fila correspondiente\n						const rowElement = allRowElements[index];\n						const nameField = rowElement?.querySelector(\n							'[data-field=\"name\"]'\n						);\n						// Usar el valor del campo si existe, sino el nombre del asset\n						const displayName =\n							nameField?.value?.trim() || asset.name;\n						const isIncluded = asset.includedInCalculation;\n						const opacity = isIncluded ? '' : 'opacity-50';\n						const totalForPercent = isIncluded\n							? totalIncluded\n							: totalAll;\n\n						return `\n							<li class=\"flex items-center justify-between rounded-lg border border-gray-700 bg-gray-700/50 px-3 py-2 text-sm ${opacity}\">\n								<strong class=\"text-gray-200\">${displayName}</strong>\n								<span class=\"font-medium text-blue-400\">${percentFormatter.format(asset.current / totalForPercent)}</span>\n							</li>\n						`;\n					})\n					.join('');\n			} catch (error) {\n				// Ignorar errores en modo no estricto\n			}\n		};\n\n		updateCurrentDistribution();\n\n		const normalizeTargets = (assets, marginFraction) => {\n			const sumTargets = assets.reduce(\n				(sum, asset) => sum + asset.target,\n				0\n			);\n			if (sumTargets <= 0) {\n				throw new Error('La suma de objetivos debe ser mayor que 0 %.');\n			}\n\n			return assets.map((asset) => {\n				const weight = asset.target / sumTargets;\n				const minShare = clamp(weight - marginFraction, 0, 1);\n				const maxShare = clamp(weight + marginFraction, 0, 1);\n				if (maxShare <= 0 && asset.current > 0) {\n					throw new Error(\n						`El margen no permite mantener ${asset.name} sin vender.`\n					);\n				}\n				return { ...asset, weight, minShare, maxShare };\n			});\n		};\n\n		const projectToBounds = (targets, mins, maxs, total) => {\n			const minSum = mins.reduce((sum, value) => sum + value, 0);\n			const maxSum = maxs.reduce((sum, value) => sum + value, 0);\n\n			if (total < minSum - 1e-6) {\n				throw new Error(\n					'El presupuesto disponible es insuficiente para respetar los m\xEDnimos dentro del margen.'\n				);\n			}\n\n			if (total > maxSum + 1e-6) {\n				throw new Error(\n					'Los objetivos y el margen no permiten usar todo el presupuesto sin sobrepasar l\xEDmites.'\n				);\n			}\n\n			const allocations = targets.map((value, index) =>\n				clamp(value, mins[index], maxs[index])\n			);\n\n			for (let i = 0; i < 80; i++) {\n				const currentTotal = allocations.reduce(\n					(sum, value) => sum + value,\n					0\n				);\n				const diff = total - currentTotal;\n				if (Math.abs(diff) <= 1e-6) break;\n\n				const freeIndexes = allocations\n					.map((value, index) => ({ value, index }))\n					.filter(\n						(item) =>\n							item.value > mins[item.index] + 1e-9 &&\n							item.value < maxs[item.index] - 1e-9\n					);\n\n				if (!freeIndexes.length) break;\n\n				const share = diff / freeIndexes.length;\n				let adjusted = false;\n\n				freeIndexes.forEach((item) => {\n					let candidate = allocations[item.index] + share;\n					if (candidate < mins[item.index]) {\n						candidate = mins[item.index];\n						adjusted = true;\n					} else if (candidate > maxs[item.index]) {\n						candidate = maxs[item.index];\n						adjusted = true;\n					}\n					allocations[item.index] = candidate;\n				});\n\n				if (!adjusted && Math.abs(diff) <= 1e-6) break;\n			}\n\n			const finalTotal = allocations.reduce((sum, v) => sum + v, 0);\n			if (Math.abs(finalTotal - total) > 1e-4) {\n				throw new Error(\n					'No se pudo encontrar una distribuci\xF3n v\xE1lida con las restricciones actuales.'\n				);\n			}\n\n			return allocations;\n		};\n\n		const raiseGroupMinimums = (mins, maxs, groups) => {\n			let unresolved = 0;\n			groups.forEach((group) => {\n				const currentMin = group.indexes.reduce(\n					(sum, idx) => sum + mins[idx],\n					0\n				);\n				let deficit = group.required - currentMin;\n				let safety = 0;\n\n				while (deficit > 1e-6) {\n					safety += 1;\n					if (safety > 50) break;\n					const adjustable = group.indexes.filter(\n						(idx) => maxs[idx] - mins[idx] > 1e-9\n					);\n					if (!adjustable.length) {\n						unresolved += deficit;\n						break;\n					}\n					const totalRoom = adjustable.reduce(\n						(sum, idx) => sum + (maxs[idx] - mins[idx]),\n						0\n					);\n					if (totalRoom + 1e-6 < deficit) {\n						// Llevar todo a su m\xE1ximo posible\n						adjustable.forEach((idx) => {\n							mins[idx] = maxs[idx];\n						});\n						unresolved += deficit - totalRoom;\n						break;\n					}\n\n					adjustable.forEach((idx) => {\n						const room = maxs[idx] - mins[idx];\n						const addition = Math.min(\n							room,\n							(room / totalRoom) * deficit\n						);\n						mins[idx] += addition;\n					});\n\n					const newMin = group.indexes.reduce(\n						(sum, idx) => sum + mins[idx],\n						0\n					);\n					deficit = group.required - newMin;\n				}\n			});\n			return unresolved;\n		};\n\n		const computeWithTransfers = (assets, budget) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n\n			// PASO 1: Calcular asignaci\xF3n solo con traspasos (sin a\xF1adir dinero)\n			const transferTotal = currentTotal;\n			const transferMins = normalized.map(\n				(asset) => asset.minShare * transferTotal\n			);\n			const transferMaxs = normalized.map(\n				(asset) => asset.maxShare * transferTotal\n			);\n			const transferTargets = normalized.map(\n				(asset) => asset.weight * transferTotal\n			);\n\n			// ETFs no pueden venderse\n			normalized.forEach((asset, idx) => {\n				if (asset.wholeUnits) {\n					transferMins[idx] = Math.max(\n						transferMins[idx],\n						asset.current\n					);\n					transferMaxs[idx] = Math.max(\n						transferMaxs[idx],\n						asset.current\n					);\n				}\n			});\n\n			// Asegurar que maxs >= mins\n			normalized.forEach((asset, idx) => {\n				transferMaxs[idx] = Math.max(\n					transferMaxs[idx],\n					transferMins[idx]\n				);\n			});\n\n			// Verificar factibilidad antes de proyectar\n			const transferMinSum = transferMins.reduce((sum, v) => sum + v, 0);\n			if (transferMinSum > transferTotal + 1e-6) {\n				// Escalar m\xEDnimos proporcionalmente\n				const scale = transferTotal / transferMinSum;\n				normalized.forEach((asset, idx) => {\n					transferMins[idx] *= scale;\n					transferMaxs[idx] = Math.max(\n						transferMaxs[idx],\n						transferMins[idx]\n					);\n				});\n			}\n\n			const transferAllocations = projectToBounds(\n				transferTargets,\n				transferMins,\n				transferMaxs,\n				transferTotal\n			);\n\n			// Verificar si realmente hay ventas necesarias (alg\xFAn activo debe reducir su valor)\n			const hasSales = normalized.some(\n				(asset, idx) => transferAllocations[idx] < asset.current - 1e-6\n			);\n\n			// Si no hay ventas necesarias, usar la misma l\xF3gica que allocateWithBudget\n			if (!hasSales) {\n				return allocateWithBudget(assets, budget);\n			}\n\n			// PASO 2: Calcular m\xEDnimo dinero adicional necesario\n			const calcMinNeeded = () => {\n				let low = transferTotal;\n				let high = transferTotal * 3;\n\n				const feasible = (total) => {\n					try {\n						const mins = normalized.map(\n							(asset) => asset.minShare * total\n						);\n						const maxs = normalized.map(\n							(asset) => asset.maxShare * total\n						);\n						const targets = normalized.map(\n							(asset) => asset.weight * total\n						);\n\n						normalized.forEach((asset, idx) => {\n							if (asset.wholeUnits) {\n								mins[idx] = Math.max(mins[idx], asset.current);\n							} else {\n								mins[idx] = Math.max(\n									mins[idx],\n									transferAllocations[idx]\n								);\n							}\n						});\n\n						// Verificar si los m\xEDnimos son factibles\n						const minSum = mins.reduce((sum, v) => sum + v, 0);\n						if (minSum > total + 1e-6) {\n							return false;\n						}\n\n						// Asegurar que maxs >= mins\n						normalized.forEach((asset, idx) => {\n							maxs[idx] = Math.max(maxs[idx], mins[idx]);\n						});\n\n						const allocs = projectToBounds(\n							targets,\n							mins,\n							maxs,\n							total\n						);\n						const needed = normalized.reduce((sum, asset, idx) => {\n							const need = allocs[idx] - transferAllocations[idx];\n							return sum + Math.max(0, need);\n						}, 0);\n\n						return transferTotal + needed <= total + 1e-6;\n					} catch (e) {\n						return false;\n					}\n				};\n\n				for (let i = 0; i < 60; i++) {\n					const mid = (low + high) / 2;\n					if (feasible(mid)) {\n						high = mid;\n					} else {\n						low = mid;\n					}\n					if (high - low < 1e-6) break;\n				}\n				return high;\n			};\n\n			const minNeededTotal = calcMinNeeded();\n			const minNeededBudget = minNeededTotal - currentTotal;\n\n			// PASO 3: Determinar total final y asignaciones\n			let finalTotal;\n			let allocations;\n\n			if (budget <= 0) {\n				// Sin presupuesto: usar solo traspasos (sin a\xF1adir dinero)\n				finalTotal = currentTotal;\n				allocations = transferAllocations; // Usar directamente las asignaciones de traspasos\n			} else {\n				// Con presupuesto: combinar traspasos con compras\n				// Intentar usar todo el presupuesto disponible\n				const candidateTotal = currentTotal + budget;\n				// Si el candidato es mayor o igual al m\xEDnimo, usarlo\n				// De lo contrario, usar el m\xEDnimo (pero esto generar\xE1 un warning)\n				finalTotal = Math.max(candidateTotal, minNeededTotal);\n\n				// PASO 4: Calcular asignaci\xF3n final con presupuesto\n				const mins = normalized.map(\n					(asset) => asset.minShare * finalTotal\n				);\n				const maxs = normalized.map(\n					(asset) => asset.maxShare * finalTotal\n				);\n				const targets = normalized.map(\n					(asset) => asset.weight * finalTotal\n				);\n\n				// Establecer m\xEDnimos: ETFs no pueden bajar, fondos pueden bajar hasta lo que tienen tras traspasos\n				normalized.forEach((asset, idx) => {\n					if (asset.wholeUnits) {\n						mins[idx] = Math.max(mins[idx], asset.current);\n					} else {\n						// Fondos pueden vender hasta lo que tienen tras traspasos\n						const minFromTransfer = transferAllocations[idx];\n						mins[idx] = Math.max(mins[idx], minFromTransfer);\n					}\n				});\n\n				// Asegurar que la suma de m\xEDnimos no exceda el total\n				const minSum = mins.reduce((sum, v) => sum + v, 0);\n				if (minSum > finalTotal + 1e-6) {\n					// Escalar los m\xEDnimos de fondos proporcionalmente\n					const fixedSum = normalized.reduce(\n						(sum, asset, idx) =>\n							sum + (asset.wholeUnits ? mins[idx] : 0),\n						0\n					);\n					const availableForFonds = Math.max(\n						0,\n						finalTotal - fixedSum\n					);\n					const fondsMinSum = normalized.reduce(\n						(sum, asset, idx) =>\n							sum + (!asset.wholeUnits ? mins[idx] : 0),\n						0\n					);\n\n					if (fondsMinSum > 1e-6) {\n						const scale = availableForFonds / fondsMinSum;\n						normalized.forEach((asset, idx) => {\n							if (!asset.wholeUnits) {\n								mins[idx] *= scale;\n							}\n						});\n					}\n				}\n\n				// Asegurar que maxs >= mins\n				normalized.forEach((asset, idx) => {\n					maxs[idx] = Math.max(maxs[idx], mins[idx]);\n				});\n\n				allocations = projectToBounds(targets, mins, maxs, finalTotal);\n			}\n\n			const breakdown = normalized.map((asset, index) => {\n				const desired = allocations[index];\n				let addition = desired - asset.current;\n\n				if (asset.wholeUnits && addition < 0) {\n					addition = 0;\n				}\n\n				const units =\n					asset.price > 0 ? addition / asset.price : addition;\n				return { ...asset, desired, addition, units };\n			});\n\n			const buys = breakdown.reduce(\n				(sum, asset) => sum + Math.max(0, asset.addition),\n				0\n			);\n			const sells = breakdown.reduce(\n				(sum, asset) => sum + Math.max(0, -asset.addition),\n				0\n			);\n			const netSpent = buys - sells;\n\n			const providedBudget = budget > 0 ? budget : 0;\n\n			// Calcular cu\xE1nto dinero adicional se necesita despu\xE9s de los traspasos\n			const additionalNeeded = breakdown.reduce((sum, asset) => {\n				// Solo contar compras (addition > 0)\n				return sum + Math.max(0, asset.addition);\n			}, 0);\n\n			// Si hay presupuesto, el importe realmente usado es el m\xEDnimo entre netSpent y el presupuesto\n			// Si no hay presupuesto, es 0 (solo traspasos)\n			const actualNeeded =\n				providedBudget > 0 ? Math.min(netSpent, providedBudget) : 0;\n			// El dinero adicional necesario es el que se necesita para las compras\n			const extraNeeded =\n				budget <= 0\n					? additionalNeeded\n					: Math.max(0, netSpent - providedBudget);\n\n			let bestEffort = null;\n			let warning = null;\n\n			// Si no hay presupuesto y se necesita dinero adicional despu\xE9s de traspasos\n			if (budget <= 0 && extraNeeded > 1e-6) {\n				warning = {\n					type: 'additional_needed',\n					message: `Despu\xE9s de realizar los traspasos necesarios, se requiere aportar ${numberFormatter.format(extraNeeded)} adicionales para alcanzar los objetivos dentro del margen.`,\n					minRequired: extraNeeded,\n				};\n			} else if (providedBudget > 0 && extraNeeded > 1e-6) {\n				const targetAdds = breakdown.map(\n					(asset) => asset.addition || 0\n				);\n				const totalNeeded = targetAdds.reduce(\n					(sum, val) => sum + Math.max(0, val),\n					0\n				);\n				const factor =\n					totalNeeded > 0\n						? Math.min(1, providedBudget / totalNeeded)\n						: 0;\n\n				const bestAlloc = normalized.map((asset, index) => {\n					const scaledAdd = Math.max(0, targetAdds[index]) * factor;\n					const desired = asset.current + scaledAdd;\n					const units =\n						asset.price > 0 ? scaledAdd / asset.price : scaledAdd;\n					return {\n						...asset,\n						desired,\n						addition: scaledAdd,\n						units,\n					};\n				});\n\n				bestEffort = {\n					breakdown: bestAlloc,\n					invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),\n				};\n\n				warning = {\n					type: 'insufficient',\n					message: `El presupuesto indicado (${numberFormatter.format(\n						providedBudget\n					)}) es insuficiente. Se necesitan al menos ${numberFormatter.format(\n						netSpent\n					)} para alcanzar los m\xEDnimos dentro del margen establecido.`,\n					minRequired: netSpent,\n				};\n			}\n\n			return {\n				breakdown,\n				bestEffort,\n				totals: {\n					mode: providedBudget > 0 ? 'budget' : 'transfers',\n					currentTotal,\n					finalTotal,\n					budget: budget <= 0 ? additionalNeeded : providedBudget,\n					budgetProvided: providedBudget,\n					extraNeeded,\n					invested: budget <= 0 ? 0 : netSpent,\n					leftover: 0,\n					allowTransfers: true,\n				},\n				warning,\n			};\n		};\n\n		const ensureOverweightConstraint = (assets, total) =>\n			assets.every((asset) => {\n				if (asset.maxShare <= 0) {\n					return asset.current <= 1e-6;\n				}\n				return asset.current <= asset.maxShare * total + 1e-6;\n			});\n\n		const minimalContribution = (assets) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n\n			const minTotalFromOverweight = normalized.reduce((max, asset) => {\n				if (asset.maxShare <= 0) {\n					return asset.current <= 0 ? max : Infinity;\n				}\n				return Math.max(max, asset.current / asset.maxShare);\n			}, currentTotal);\n\n			let low = Math.max(currentTotal, minTotalFromOverweight);\n			let high = Number.isFinite(low) ? low : currentTotal + 1;\n\n			const requiredAddition = (total) =>\n				normalized.reduce((sum, asset) => {\n					const targetValue = asset.minShare * total;\n					return sum + Math.max(0, targetValue - asset.current);\n				}, 0);\n\n			const feasible = (total) => {\n				if (!Number.isFinite(total)) return false;\n				if (!ensureOverweightConstraint(normalized, total))\n					return false;\n				const additions = requiredAddition(total);\n				return currentTotal + additions <= total + 1e-6;\n			};\n\n			if (!feasible(high)) {\n				while (!feasible(high)) {\n					high *= 2;\n					if (high > 1e12) {\n						throw new Error(\n							'No se puede alcanzar la distribuci\xF3n con el margen indicado.'\n						);\n					}\n				}\n			}\n\n			for (let i = 0; i < 60; i++) {\n				const mid = (low + high) / 2;\n				if (feasible(mid)) {\n					high = mid;\n				} else {\n					low = mid;\n				}\n			}\n\n			const finalTotal = high;\n			const breakdown = normalized.map((asset) => {\n				const desired = Math.max(\n					asset.current,\n					asset.minShare * finalTotal\n				);\n				const addition = Math.max(0, desired - asset.current);\n				const units = asset.price > 0 ? addition / asset.price : 0;\n				return { ...asset, desired, addition, units };\n			});\n\n			const invested = breakdown.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n			return {\n				breakdown,\n				totals: {\n					mode: 'minimal',\n					currentTotal,\n					finalTotal,\n					invested,\n				},\n			};\n		};\n\n		const allocateWithBudget = (assets, budget) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n			const finalTotal = currentTotal + budget;\n\n			let warning = null;\n			let minimalResult = null;\n			let isOverweight = false;\n\n			// Verificar si hay activos sobreponderados\n			if (!ensureOverweightConstraint(normalized, finalTotal)) {\n				// Calcular el m\xEDnimo necesario (lo ideal)\n				minimalResult = minimalContribution(assets);\n				warning = {\n					type: 'overweight',\n					message: `\u26A0\uFE0F Con el presupuesto actual (${numberFormatter.format(budget)}) algunos activos quedar\xEDan sobreponderados. Se necesitar\xEDan al menos ${numberFormatter.format(minimalResult.totals.invested)} para mantener el balance dentro del margen.`,\n					minRequired: minimalResult.totals.invested,\n				};\n				isOverweight = true;\n			}\n\n			// Calcular l\xEDmites: si un activo est\xE1 sobreponderado, no puede crecer ni bajar\n			const lowerBounds = normalized.map((asset) => {\n				const maxFromMargin = asset.maxShare * finalTotal;\n				// Si el activo est\xE1 sobreponderado, no puede bajar (su m\xEDnimo es su valor actual)\n				if (asset.current > maxFromMargin + 1e-6) {\n					return asset.current;\n				}\n				return Math.max(asset.current, asset.minShare * finalTotal);\n			});\n			const upperBounds = normalized.map((asset, index) => {\n				const maxFromMargin = asset.maxShare * finalTotal;\n				// Si el activo ya est\xE1 sobreponderado, su m\xE1ximo es su valor actual\n				if (asset.current > maxFromMargin + 1e-6) {\n					return asset.current;\n				}\n				return Math.max(lowerBounds[index], maxFromMargin);\n			});\n\n			const sumLower = lowerBounds.reduce((sum, value) => sum + value, 0);\n			if (sumLower - finalTotal > 1e-6) {\n				const minRequired = sumLower - currentTotal;\n				warning = {\n					type: 'insufficient',\n					message: `\u26A0\uFE0F El presupuesto indicado (${numberFormatter.format(budget)}) es insuficiente. Se necesitan al menos ${numberFormatter.format(minRequired)} para alcanzar los m\xEDnimos dentro del margen establecido.`,\n					minRequired: minRequired,\n				};\n			}\n\n			let allocations = [...lowerBounds];\n			let remaining = finalTotal - sumLower;\n\n			let flex = normalized\n				.map((asset, index) => ({\n					index,\n					capacity: upperBounds[index] - allocations[index],\n				}))\n				.filter((item) => item.capacity > 1e-6);\n\n			while (flex.length && remaining > 1e-6) {\n				const weightSum = flex.reduce(\n					(sum, item) => sum + normalized[item.index].weight,\n					0\n				);\n				if (weightSum <= 0) break;\n\n				let consumed = 0;\n				const nextFlex = [];\n\n				flex.forEach((item) => {\n					const asset = normalized[item.index];\n					const share = (asset.weight / weightSum) * remaining;\n					if (share >= item.capacity - 1e-9) {\n						allocations[item.index] += item.capacity;\n						consumed += item.capacity;\n					} else {\n						allocations[item.index] += share;\n						consumed += share;\n						nextFlex.push({\n							index: item.index,\n							capacity: item.capacity - share,\n						});\n					}\n				});\n\n				if (consumed <= 1e-9) break;\n				remaining -= consumed;\n				flex = nextFlex;\n			}\n\n			const leftover = Math.max(0, remaining);\n\n			const breakdown = normalized.map((asset, index) => {\n				const desired = allocations[index];\n				const addition = Math.max(0, desired - asset.current);\n				const units = asset.price > 0 ? addition / asset.price : 0;\n				return { ...asset, desired, addition, units };\n			});\n\n			const invested = breakdown.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n\n			let bestEffort = null;\n			if (warning && warning.type === 'insufficient') {\n				const targetAdds = breakdown.map(\n					(asset) => asset.addition || 0\n				);\n				const totalNeeded = targetAdds.reduce(\n					(sum, val) => sum + val,\n					0\n				);\n				const factor =\n					totalNeeded > 0 ? Math.min(1, budget / totalNeeded) : 0;\n\n				const bestAlloc = normalized.map((asset, index) => {\n					const scaledAdd = targetAdds[index] * factor;\n					const desired = asset.current + scaledAdd;\n					const units =\n						asset.price > 0 ? scaledAdd / asset.price : scaledAdd;\n					return {\n						...asset,\n						desired,\n						addition: scaledAdd,\n						units,\n					};\n				});\n\n				bestEffort = {\n					breakdown: bestAlloc,\n					invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),\n				};\n			}\n\n			// Si hay sobreponderaci\xF3n, intercambiar breakdown y bestEffort\n			// breakdown principal = lo ideal (minimalResult)\n			// bestEffort = lo que realmente se puede hacer con el presupuesto disponible\n			// (distribuyendo el presupuesto sin exceder los m\xE1ximos)\n			if (isOverweight && minimalResult) {\n				// Calcular un bestEffort que respete los l\xEDmites m\xE1ximos y use exactamente el presupuesto\n				const safeFinalTotal = currentTotal + budget;\n\n				// L\xEDmites m\xEDnimos: no bajar de lo actual\n				const safeMins = normalized.map((asset) => asset.current);\n\n				// L\xEDmites m\xE1ximos: respetar el m\xE1ximo del margen en el total final\n				// Si un activo ya est\xE1 sobreponderado, su m\xE1ximo es su valor actual\n				const safeMaxs = normalized.map((asset, idx) => {\n					const maxFromMargin = asset.maxShare * safeFinalTotal;\n					// Si el activo ya est\xE1 por encima del m\xE1ximo permitido, no puede crecer\n					if (asset.current > maxFromMargin + 1e-6) {\n						return asset.current;\n					}\n					return Math.max(safeMins[idx], maxFromMargin);\n				});\n\n				// Empezar desde los m\xEDnimos\n				let safeAllocations = [...safeMins];\n				let remaining = budget;\n\n				// Distribuir el presupuesto respetando los m\xE1ximos\n				let flex = normalized\n					.map((asset, index) => ({\n						index,\n						capacity: safeMaxs[index] - safeAllocations[index],\n					}))\n					.filter((item) => item.capacity > 1e-6);\n\n				while (flex.length && remaining > 1e-6) {\n					const weightSum = flex.reduce(\n						(sum, item) => sum + normalized[item.index].weight,\n						0\n					);\n					if (weightSum <= 0) break;\n\n					let consumed = 0;\n					const nextFlex = [];\n\n					flex.forEach((item) => {\n						const asset = normalized[item.index];\n						const share = (asset.weight / weightSum) * remaining;\n						if (share >= item.capacity - 1e-9) {\n							safeAllocations[item.index] += item.capacity;\n							consumed += item.capacity;\n						} else {\n							safeAllocations[item.index] += share;\n							consumed += share;\n							nextFlex.push({\n								index: item.index,\n								capacity: item.capacity - share,\n							});\n						}\n					});\n\n					if (consumed <= 1e-9) break;\n					remaining -= consumed;\n					flex = nextFlex;\n				}\n\n				const safeBreakdown = normalized.map((asset, index) => {\n					const desired = safeAllocations[index];\n					const addition = Math.max(0, desired - asset.current);\n					const units = asset.price > 0 ? addition / asset.price : 0;\n					return { ...asset, desired, addition, units };\n				});\n\n				// El presupuesto usado es el total del presupuesto menos el leftover\n				const safeInvested = budget - Math.max(0, remaining);\n\n				return {\n					breakdown: minimalResult.breakdown,\n					bestEffort: {\n						breakdown: safeBreakdown,\n						invested: safeInvested,\n					},\n					totals: {\n						mode: 'budget',\n						currentTotal,\n						finalTotal: minimalResult.totals.finalTotal,\n						budget: minimalResult.totals.invested,\n						invested: minimalResult.totals.invested,\n						leftover: Math.max(0, remaining),\n					},\n					warning,\n				};\n			}\n\n			return {\n				breakdown,\n				bestEffort,\n				totals: {\n					mode: 'budget',\n					currentTotal,\n					finalTotal,\n					budget,\n					invested,\n					leftover,\n				},\n				warning,\n			};\n		};\n\n		const applyUnitConstraints = (breakdown, totals, allowTransfers) => {\n			const targetSpend =\n				totals.mode === 'budget' ? totals.budget : totals.invested;\n\n			const adjusted = breakdown.map((asset) => {\n				let addition = asset.addition;\n				let units = asset.price > 0 ? asset.addition / asset.price : 0;\n\n				if (asset.wholeUnits && asset.price > 0) {\n					if (addition >= 0) {\n						if (totals.mode === 'minimal') {\n							units = Math.ceil(units - 1e-9);\n						} else {\n							units = Math.floor(units + 1e-9);\n						}\n					} else {\n						// Ventas: aproximar hacia cero para no sobre-vender\n						units = Math.ceil(units - 1e-9);\n					}\n					addition = units * asset.price;\n				}\n\n				return { ...asset, addition, units };\n			});\n\n			const buys = adjusted.reduce(\n				(sum, asset) => sum + Math.max(0, asset.addition),\n				0\n			);\n			const sells = adjusted.reduce(\n				(sum, asset) => sum + Math.max(0, -asset.addition),\n				0\n			);\n\n			const netSpent = adjusted.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n\n			// Calcular leftover: cuando hay presupuesto, usar el presupuesto disponible menos lo gastado\n			let leftover = 0;\n			if (totals.mode === 'budget') {\n				leftover = Math.max(0, targetSpend - netSpent);\n			} else if (allowTransfers && totals.budgetProvided > 0) {\n				// Cuando hay traspasos y presupuesto, calcular leftover basado en el presupuesto disponible\n				leftover = Math.max(0, totals.budgetProvided - netSpent);\n			}\n\n			if (leftover > 0.01) {\n				const fractional = adjusted.filter(\n					(asset) => !asset.wholeUnits || asset.price <= 0\n				);\n\n				fractional\n					.sort(\n						(a, b) =>\n							b.desired -\n							(b.current + b.addition) -\n							(a.desired - (a.current + a.addition))\n					)\n					.forEach((asset) => {\n						if (leftover <= 0.01) return;\n						const gap =\n							asset.desired - (asset.current + asset.addition);\n						if (gap <= 0) return;\n						const delta = Math.min(gap, leftover);\n						asset.addition += delta;\n						if (asset.price > 0 && !asset.wholeUnits) {\n							asset.units = asset.addition / asset.price;\n						}\n						leftover -= delta;\n					});\n			}\n\n			const finalSpent = adjusted.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n			const finalTotal = totals.currentTotal + finalSpent;\n\n			return {\n				breakdown: adjusted.map((asset) => ({\n					...asset,\n					finalShare:\n						finalTotal > 0\n							? (asset.current + asset.addition) / finalTotal\n							: 0,\n				})),\n				spent: finalSpent,\n				leftover,\n				finalTotal,\n				buys,\n				sells,\n				net: finalSpent,\n			};\n		};\n\n		const generateStepGuide = (breakdown, totals, bestApplied) => {\n			// Usar bestApplied si existe (aportaci\xF3n real), sino usar breakdown (lo ideal)\n			const activeBreakdown =\n				bestApplied && bestApplied.breakdown\n					? bestApplied.breakdown\n					: breakdown;\n\n			const steps = [];\n			let stepNumber = 1;\n\n			// Separar ventas y compras, diferenciando fondos (no wholeUnits) de ETFs (wholeUnits)\n			const sales = activeBreakdown\n				.filter((asset) => asset.addition < -1e-6)\n				.map((asset) => ({\n					name: asset.name,\n					amount: Math.abs(asset.addition),\n					units:\n						asset.units && asset.wholeUnits && asset.price > 0\n							? Math.abs(Math.round(asset.units))\n							: null,\n					price: asset.price,\n					wholeUnits: asset.wholeUnits,\n				}));\n\n			const purchases = activeBreakdown\n				.filter((asset) => asset.addition > 1e-6)\n				.map((asset) => ({\n					name: asset.name,\n					amount: asset.addition,\n					units:\n						asset.units && asset.wholeUnits && asset.price > 0\n							? Math.round(asset.units)\n							: null,\n					price: asset.price,\n					wholeUnits: asset.wholeUnits,\n				}));\n\n			// Separar fondos de ETFs\n			const fundSales = sales.filter((s) => !s.wholeUnits);\n			const etfSales = sales.filter((s) => s.wholeUnits);\n			const fundPurchases = purchases.filter((p) => !p.wholeUnits);\n			const etfPurchases = purchases.filter((p) => p.wholeUnits);\n\n			// Calcular totales\n			const totalFundSales = fundSales.reduce(\n				(sum, s) => sum + s.amount,\n				0\n			);\n			const totalEtfSales = etfSales.reduce(\n				(sum, s) => sum + s.amount,\n				0\n			);\n			const totalFundPurchases = fundPurchases.reduce(\n				(sum, p) => sum + p.amount,\n				0\n			);\n			const totalEtfPurchases = etfPurchases.reduce(\n				(sum, p) => sum + p.amount,\n				0\n			);\n			const totalSales = totalFundSales + totalEtfSales;\n			const totalPurchases = totalFundPurchases + totalEtfPurchases;\n			const netNeeded = totals.allowTransfers\n				? Math.max(0, totalPurchases - totalSales)\n				: totalPurchases;\n\n			// Si hay traspasos habilitados, hacer traspasos directos entre fondos\n			if (totals.allowTransfers) {\n				// Crear traspasos directos entre fondos\n				const salesToProcess = fundSales.map((s) => ({ ...s }));\n				const purchasesToProcess = fundPurchases.map((p) => ({ ...p }));\n\n				// Emparejar ventas con compras de fondos (traspasos directos)\n				while (\n					salesToProcess.length > 0 &&\n					purchasesToProcess.length > 0\n				) {\n					const sale = salesToProcess[0];\n					const purchase = purchasesToProcess[0];\n\n					const transferAmount = Math.min(\n						sale.amount,\n						purchase.amount\n					);\n\n					// Solo a\xF1adir paso si el importe es significativo\n					if (transferAmount > 0.01) {\n						steps.push({\n							text: `<strong>${stepNumber}. Traspasa ${numberFormatter.format(transferAmount)} </strong> | <strong>${sale.name}</strong> \u2192 <strong>${purchase.name}</strong>`,\n							type: 'transfer',\n						});\n						stepNumber++;\n					}\n\n					// Actualizar montos restantes\n					sale.amount -= transferAmount;\n					purchase.amount -= transferAmount;\n\n					if (sale.amount < 1e-6) {\n						salesToProcess.shift();\n					}\n					if (purchase.amount < 1e-6) {\n						purchasesToProcess.shift();\n					}\n				}\n\n				// Si quedan ventas de fondos, seguir emparej\xE1ndolas con las compras restantes\n				while (\n					salesToProcess.length > 0 &&\n					purchasesToProcess.length > 0\n				) {\n					const sale = salesToProcess[0];\n					const purchase = purchasesToProcess[0];\n\n					const transferAmount = Math.min(\n						sale.amount,\n						purchase.amount\n					);\n\n					// Solo a\xF1adir paso si el importe es significativo\n					if (transferAmount > 0.01) {\n						steps.push({\n							text: `<strong>${stepNumber}. Traspasa ${numberFormatter.format(transferAmount)} </strong> | <strong>${sale.name}</strong> \u2192 <strong>${purchase.name}</strong>`,\n							type: 'transfer',\n						});\n						stepNumber++;\n					}\n\n					sale.amount -= transferAmount;\n					purchase.amount -= transferAmount;\n\n					if (sale.amount < 1e-6) {\n						salesToProcess.shift();\n					}\n					if (purchase.amount < 1e-6) {\n						purchasesToProcess.shift();\n					}\n				}\n\n				// ETFs: vender primero (no se pueden traspasar, solo vender/comprar)\n				etfSales.forEach((sale) => {\n					steps.push({\n						text: `<strong>${stepNumber}. Vende ${numberFormatter.format(sale.amount)} </strong> | <strong>${sale.name}</strong>`,\n						type: 'transfer',\n					});\n					stepNumber++;\n				});\n\n				// Si hay dinero adicional necesario despu\xE9s de los traspasos\n				if (netNeeded > 1e-6) {\n					steps.push({\n						text: `<strong>${stepNumber}. Aporta ${numberFormatter.format(netNeeded)} adicionales para completar las compras</strong>`,\n						type: 'contribution',\n					});\n					stepNumber++;\n				}\n\n				// Compras de fondos que no fueron cubiertas por traspasos\n				purchasesToProcess.forEach((purchase) => {\n					if (purchase.amount > 1e-6) {\n						steps.push({\n							text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,\n							type: 'purchase',\n						});\n						stepNumber++;\n					}\n				});\n\n				// Compras de ETFs\n				etfPurchases.forEach((purchase) => {\n					steps.push({\n						text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,\n						type: 'purchase',\n					});\n					stepNumber++;\n				});\n			} else {\n				// Sin traspasos, mostrar primero la aportaci\xF3n necesaria\n				if (netNeeded > 1e-6) {\n					steps.push({\n						text: `<strong>${stepNumber}. Aporta ${numberFormatter.format(netNeeded)}</strong>`,\n						type: 'contribution',\n					});\n					stepNumber++;\n				}\n\n				// Mostrar las compras\n				purchases.forEach((purchase) => {\n					steps.push({\n						text: `<strong>${stepNumber}. Compra ${numberFormatter.format(purchase.amount)} </strong> | <strong>${purchase.name}</strong>`,\n						type: 'purchase',\n					});\n					stepNumber++;\n				});\n			}\n\n			// Si no hay acciones\n			if (steps.length === 0) {\n				steps.push({\n					text: '<strong>1. No se requieren acciones. Tu cartera ya cumple con los objetivos dentro del margen establecido.</strong>',\n					type: 'info',\n				});\n			}\n\n			// Mostrar leftover si existe\n			if (totals.leftover > 0.01) {\n				steps.push({\n					text: `<strong>Nota:</strong> Quedan ${numberFormatter.format(totals.leftover)} sin asignar debido a restricciones de unidades completas.`,\n					type: 'info',\n				});\n			}\n\n			return steps;\n		};\n\n		const renderResults = (breakdown, totals, bestApplied) => {\n			const summaryItems = [\n				{\n					label: 'Total actual',\n					value: numberFormatter.format(totals.currentTotal),\n				},\n				{\n					label: 'Total tras inversi\xF3n',\n					value: numberFormatter.format(totals.finalTotal),\n				},\n				{\n					label: totals.allowTransfers\n						? 'Importe neto (compras - ventas)'\n						: totals.mode === 'budget'\n							? 'Importe a invertir'\n							: 'M\xEDnimo a invertir',\n					value: numberFormatter.format(totals.invested),\n				},\n			];\n\n			if (totals.mode === 'budget') {\n				const budgetItems = [\n					{\n						label: 'Presupuesto calculado',\n						value: numberFormatter.format(totals.budget),\n					},\n				];\n\n				if (\n					totals.allowTransfers &&\n					typeof totals.budgetProvided !== 'undefined'\n				) {\n					budgetItems.push({\n						label: 'Presupuesto indicado',\n						value: numberFormatter.format(totals.budgetProvided),\n					});\n				}\n\n				if (totals.allowTransfers && totals.extraNeeded > 0.01) {\n					budgetItems.push({\n						label: 'Extra para evitar cruzar tipos',\n						value: numberFormatter.format(totals.extraNeeded),\n					});\n				}\n\n				summaryItems.push(...budgetItems);\n\n				if (totals.leftover > 0.01) {\n					summaryItems.push({\n						label: 'Sobrante sin asignar',\n						value: numberFormatter.format(totals.leftover),\n					});\n				}\n			}\n\n			if (\n				totals.allowTransfers &&\n				totals.mode !== 'budget' &&\n				totals.extraNeeded > 0.01\n			) {\n				summaryItems.push({\n					label: 'Extra necesario para rebalancear por tipos',\n					value: numberFormatter.format(totals.extraNeeded),\n				});\n			}\n\n			if (totals.allowTransfers && totals.sells > 0.01) {\n				summaryItems.push(\n					{\n						label: 'Compras estimadas',\n						value: numberFormatter.format(totals.buys),\n					},\n					{\n						label: 'Ventas estimadas',\n						value: numberFormatter.format(totals.sells),\n					}\n				);\n			}\n\n			summaryItems.push({\n				label: 'Margen aplicado',\n				value: `${marginNumberFormatter.format(getMarginValue())} %`,\n			});\n\n			summaryEl.innerHTML = summaryItems\n				.map(\n					(item) => `\n				<div class=\"rounded-lg border border-gray-700 bg-gray-800/70 p-3 sm:p-4\">\n					<div class=\"text-xs text-gray-400 sm:text-sm\">${item.label}</div>\n					<div class=\"mt-1 text-lg font-bold text-gray-100 sm:text-xl\">${item.value}</div>\n				</div>`\n				)\n				.join('');\n\n			tbody.innerHTML = '';\n			breakdown.forEach((asset, index) => {\n				const row = document.createElement('tr');\n				row.className =\n					index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';\n\n				const bestAsset =\n					bestApplied && bestApplied.breakdown\n						? bestApplied.breakdown[index]\n						: null;\n\n				const unitsLabel =\n					asset.price > 0\n						? asset.wholeUnits\n							? `${asset.units.toFixed(0)} ud`\n							: unitFormatter.format(asset.units)\n						: '\u2014';\n				const additionClass =\n					asset.addition > 0\n						? 'text-green-400'\n						: asset.addition < 0\n							? 'text-red-400'\n							: 'text-gray-300';\n\n				const bestAddition =\n					bestAsset && typeof bestAsset.addition === 'number'\n						? bestAsset.addition\n						: null;\n				const bestClass =\n					bestAddition === null\n						? ''\n						: bestAddition > 0\n							? 'text-green-400'\n							: bestAddition < 0\n								? 'text-red-400'\n								: 'text-gray-300';\n				const bestUnitsLabel =\n					bestAsset && bestAsset.price > 0\n						? bestAsset.wholeUnits\n							? `${bestAsset.units.toFixed(0)} ud`\n							: unitFormatter.format(bestAsset.units)\n						: bestAsset\n							? '\u2014'\n							: null;\n\n				row.innerHTML = `\n					<td class=\"px-3 py-2 text-xs text-gray-200 sm:px-4 sm:py-3 sm:text-sm\">${asset.name}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">${numberFormatter.format(asset.current)}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">${numberFormatter.format(asset.desired)}</td>\n					<td class=\"px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm ${additionClass}\">${numberFormatter.format(\n						asset.addition\n					)}</td>\n					<td class=\"px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm ${bestClass}\">${\n						bestAsset ? numberFormatter.format(bestAddition) : '\u2014'\n					}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">${unitsLabel}</td>\n					<td class=\"px-3 py-2 text-xs font-medium text-blue-400 sm:px-4 sm:py-3 sm:text-sm\">${percentFormatter.format(asset.finalShare)}</td>\n				`;\n				tbody.appendChild(row);\n			});\n\n			const positiveAssets = breakdown.filter(\n				(asset) => asset.addition > 0\n			);\n			const negativeAssets = breakdown.filter(\n				(asset) => asset.addition < 0\n			);\n\n			if (!positiveAssets.length) {\n				if (totals.allowTransfers && negativeAssets.length) {\n					const sellAsset = negativeAssets.reduce((prev, current) =>\n						-current.addition > -prev.addition ? current : prev\n					);\n					adviceEl.textContent = `Solo necesitas traspasos: reduce ${sellAsset.name} en ${numberFormatter.format(\n						Math.abs(sellAsset.addition)\n					)} y redistribuye seg\xFAn la tabla.`;\n				} else {\n					adviceEl.textContent =\n						'Ya cumples la distribuci\xF3n objetivo; no es necesario aportar m\xE1s.';\n				}\n				return;\n			}\n\n			const maxAsset = positiveAssets.reduce((prev, current) =>\n				current.addition > prev.addition ? current : prev\n			);\n\n			const baseMessage =\n				totals.mode === 'budget'\n					? `Con el presupuesto indicado empieza por ${maxAsset.name}, requiere ${numberFormatter.format(\n							maxAsset.addition\n						)}.`\n					: `Para alcanzar la distribuci\xF3n dentro del margen aporta primero en ${maxAsset.name}, necesita ${numberFormatter.format(\n							maxAsset.addition\n						)}.`;\n\n			const leftoverMessage =\n				totals.mode === 'budget' && totals.leftover > 0.01\n					? ` Quedar\xE1n ${numberFormatter.format(\n							totals.leftover\n						)} libres al no poder comprar fracciones.`\n					: '';\n\n			adviceEl.textContent = `${baseMessage}${leftoverMessage}`;\n\n			// Generar y mostrar gu\xEDa paso a paso\n			const steps = generateStepGuide(breakdown, totals, bestApplied);\n			if (steps.length > 0) {\n				stepList.innerHTML = steps\n					.map((step) => {\n						let borderColor = 'border-gray-700';\n						let bgColor = 'bg-gray-700/30';\n\n						if (step.type === 'transfer') {\n							// Naranja para traspasos\n							borderColor = 'border-orange-500/50';\n							bgColor = 'bg-orange-600/10';\n						} else if (step.type === 'purchase') {\n							// Verde para compras\n							borderColor = 'border-green-500/50';\n							bgColor = 'bg-green-950/30';\n						} else if (step.type === 'contribution') {\n							// Gris para aportaciones\n							borderColor = 'border-gray-600/50';\n							bgColor = 'bg-gray-700/30';\n						} else if (step.type === 'info') {\n							// Vainilla/beige para notas\n							borderColor = 'border-yellow-200/30';\n							bgColor = 'bg-yellow-50/10';\n						}\n\n						return `<li class=\"rounded-lg border ${borderColor} ${bgColor} p-3\">${step.text}</li>`;\n					})\n					.join('');\n				stepGuide.hidden = false;\n			} else {\n				stepGuide.hidden = true;\n			}\n		};\n\n		const showError = (message) => {\n			errorBox.textContent = message;\n			errorBox.hidden = false;\n			resultsSection.hidden = true;\n		};\n\n		const clearError = () => {\n			errorBox.hidden = true;\n			errorBox.textContent = '';\n		};\n\n		const showWarning = (warning) => {\n			if (warning) {\n				errorBox.innerHTML = warning.message;\n				errorBox.hidden = false;\n			} else {\n				clearError();\n			}\n		};\n\n		// Guardar estado en localStorage\n		const saveFormState = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const state = {\n					budget: budgetInput.value,\n					margin: marginInput.value,\n					allowTransfers: transfersEnabled(),\n					assets: rows.map((row) => ({\n						name: row.name,\n						isin: row.isin,\n						current: row.current,\n						price: row.price,\n						target: row.target,\n						wholeUnits: row.wholeUnits,\n						includedInCalculation: row.includedInCalculation,\n					})),\n				};\n				localStorage.setItem(\n					'investmentCalculatorState',\n					JSON.stringify(state)\n				);\n			} catch (e) {\n				console.warn('No se pudo guardar el estado:', e);\n			}\n		};\n\n		// Cargar estado desde localStorage\n		const loadFormState = () => {\n			try {\n				const saved = localStorage.getItem('investmentCalculatorState');\n				if (saved) {\n					const state = JSON.parse(saved);\n\n					// Cargar budget y margin\n					if (state.budget !== undefined)\n						budgetInput.value = state.budget;\n					if (state.margin !== undefined)\n						marginInput.value = state.margin;\n					if (typeof state.allowTransfers !== 'undefined') {\n						setTransfersToggle(Boolean(state.allowTransfers));\n					}\n\n					// Limpiar y recrear filas\n					if (state.assets && state.assets.length > 0) {\n						rowsContainer.innerHTML = '';\n						state.assets.forEach((asset) => {\n							const fragment =\n								rowTemplate.content.cloneNode(true);\n							const row = fragment.querySelector('[data-row]');\n							rowsContainer.appendChild(fragment);\n							initializeRow(row, asset);\n						});\n					}\n\n					updateCurrentDistribution();\n					autoCalculate();\n				}\n			} catch (e) {\n				console.warn('No se pudo cargar el estado:', e);\n			}\n		};\n\n		// Auto-calcular\n		let autoCalculateTimeout;\n		const autoCalculate = () => {\n			clearTimeout(autoCalculateTimeout);\n			autoCalculateTimeout = setTimeout(() => {\n				try {\n					const allRows = getRows();\n					// Filtrar solo los activos incluidos en el c\xE1lculo\n					const rows = allRows.filter(\n						(asset) => asset.includedInCalculation\n					);\n\n					if (rows.length === 0) {\n						showError(\n							'Debe haber al menos un activo incluido en el c\xE1lculo'\n						);\n						return;\n					}\n\n					const budget = Math.max(0, sanitize(budgetInput.value));\n					const allowMove = transfersEnabled();\n					const result = allowMove\n						? computeWithTransfers(rows, budget)\n						: budget > 0\n							? allocateWithBudget(rows, budget)\n							: minimalContribution(rows);\n\n					// Verificar si realmente hay ventas/traspasos en el resultado\n					// Si no hay ventas, tratar como si no hubiera traspasos habilitados\n					const hasActualTransfers =\n						allowMove &&\n						result.breakdown.some(\n							(asset) => asset.addition < -1e-6\n						);\n\n					const appliedMain = applyUnitConstraints(\n						result.breakdown,\n						result.totals,\n						hasActualTransfers\n					);\n\n					let appliedBest = null;\n					if (result.bestEffort) {\n						const bestTotals = {\n							...result.totals,\n							invested: result.bestEffort.invested,\n							budget,\n						};\n						appliedBest = applyUnitConstraints(\n							result.bestEffort.breakdown,\n							bestTotals,\n							hasActualTransfers\n						);\n					}\n\n					const totals = {\n						...result.totals,\n						invested: hasActualTransfers\n							? appliedMain.net\n							: appliedMain.spent,\n						leftover: appliedMain.leftover,\n						finalTotal: appliedMain.finalTotal,\n						buys: appliedMain.buys,\n						sells: appliedMain.sells,\n						allowTransfers: hasActualTransfers,\n						bestEffort: appliedBest,\n					};\n\n					resultsSection.hidden = false;\n					renderResults(appliedMain.breakdown, totals, appliedBest);\n\n					// Mostrar warning si existe\n					if (result.warning) {\n						showWarning(result.warning);\n					} else {\n						clearError();\n					}\n				} catch (err) {\n					showError(err.message);\n				}\n			}, 500);\n		};\n\n		// Event listeners para inputs principales\n		budgetInput.addEventListener('input', () => {\n			saveFormState();\n			autoCalculate();\n		});\n\n		marginInput.addEventListener('input', () => {\n			saveFormState();\n			autoCalculate();\n		});\n\n		// Prevenir submit del form\n		form.addEventListener('submit', (event) => {\n			event.preventDefault();\n		});\n\n		// Exportar datos a JSON\n		const exportData = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const data = {\n					version: '1.0',\n					budget: budgetInput.value || '',\n					margin: marginInput.value || '',\n					allowTransfers: transfersEnabled(),\n					assets: rows.map((row) => ({\n						name: row.name,\n						isin: row.isin || '',\n						current: row.current,\n						price: row.price || '',\n						target: row.target,\n						wholeUnits: row.wholeUnits,\n						includedInCalculation: row.includedInCalculation,\n					})),\n				};\n\n				const jsonStr = JSON.stringify(data, null, 2);\n				const blob = new Blob([jsonStr], { type: 'application/json' });\n				const url = URL.createObjectURL(blob);\n				const a = document.createElement('a');\n				a.href = url;\n				a.download = `calculadora-inversion-${new Date().toISOString().split('T')[0]}.json`;\n				document.body.appendChild(a);\n				a.click();\n				document.body.removeChild(a);\n				URL.revokeObjectURL(url);\n			} catch (error) {\n				showError('Error al exportar los datos: ' + error.message);\n			}\n		};\n\n		// Importar datos desde JSON\n		const importData = (file) => {\n			const reader = new FileReader();\n			reader.onload = (e) => {\n				try {\n					const data = JSON.parse(e.target.result);\n\n					if (!data.assets || !Array.isArray(data.assets)) {\n						throw new Error('Formato de archivo inv\xE1lido');\n					}\n\n					// Cargar presupuesto y margen\n					if (data.budget !== undefined)\n						budgetInput.value = data.budget || '';\n					if (data.margin !== undefined)\n						marginInput.value = data.margin || '';\n					if (typeof data.allowTransfers !== 'undefined') {\n						setTransfersToggle(Boolean(data.allowTransfers));\n					}\n\n					// Limpiar y recrear filas\n					rowsContainer.innerHTML = '';\n					data.assets.forEach((asset) => {\n						const fragment = rowTemplate.content.cloneNode(true);\n						const row = fragment.querySelector('[data-row]');\n						rowsContainer.appendChild(fragment);\n						initializeRow(row, {\n							name: asset.name || '',\n							isin: asset.isin || null,\n							current: asset.current || null,\n							price: asset.price || null,\n							target: asset.target || 0,\n							wholeUnits: Boolean(asset.wholeUnits),\n							includedInCalculation:\n								typeof asset.includedInCalculation ===\n								'undefined'\n									? true\n									: Boolean(asset.includedInCalculation),\n						});\n					});\n\n					// Si no hay activos, crear uno vac\xEDo\n					if (data.assets.length === 0) {\n						const fragment = rowTemplate.content.cloneNode(true);\n						const row = fragment.querySelector('[data-row]');\n						rowsContainer.appendChild(fragment);\n						initializeRow(row);\n					}\n\n					updateCurrentDistribution();\n					saveFormState();\n					autoCalculate();\n					clearError();\n\n					// Refrescar precios de todos los ISINs\n					setTimeout(() => refreshAllPrices(), 500);\n				} catch (error) {\n					showError('Error al importar los datos: ' + error.message);\n				}\n			};\n			reader.onerror = () => {\n				showError('Error al leer el archivo');\n			};\n			reader.readAsText(file);\n		};\n\n		exportBtn.addEventListener('click', exportData);\n\n		importBtn.addEventListener('click', () => {\n			importFileInput.click();\n		});\n\n		importFileInput.addEventListener('change', (e) => {\n			const file = e.target.files[0];\n			if (file) {\n				if (\n					file.type !== 'application/json' &&\n					!file.name.endsWith('.json')\n				) {\n					showError('El archivo debe ser un JSON v\xE1lido');\n					return;\n				}\n				importData(file);\n				// Limpiar el input para permitir cargar el mismo archivo de nuevo\n				e.target.value = '';\n			}\n		});\n\n		resetBtn.addEventListener('click', () => {\n			// Limpiar localStorage\n			localStorage.removeItem('investmentCalculatorState');\n\n			form.reset();\n			setTransfersToggle(false);\n			rowsContainer.innerHTML = '';\n			initialAssets.forEach((asset) => {\n				const fragment = rowTemplate.content.cloneNode(true);\n				const row = fragment.querySelector('[data-row]');\n				rowsContainer.appendChild(fragment);\n				initializeRow(row, asset);\n			});\n			resultsSection.hidden = true;\n			clearError();\n			updateCurrentDistribution();\n			saveFormState();\n			autoCalculate();\n		});\n\n		// Cargar estado inicial al cargar la p\xE1gina\n		loadFormState();\n\n		// Refrescar precios de todos los ISINs despu\xE9s de cargar\n		setTimeout(() => refreshAllPrices(), 1000);\n	<\/script> "], [" ", '<div class="min-h-screen bg-gray-900 px-3 py-4 font-sans text-gray-100 sm:px-4 md:px-6 lg:px-8" data-astro-cid-4w4x4o4c> <h1 class="mb-4 text-2xl font-bold text-blue-500 sm:mb-6 sm:text-3xl" data-astro-cid-4w4x4o4c>\nCalculadora de Inversi\xF3n\n</h1> <div class="mx-auto w-full" data-astro-cid-4w4x4o4c> <div class="mb-4 rounded-lg border border-gray-700 bg-gray-800 p-4 shadow-lg sm:mb-6 sm:p-6" data-astro-cid-4w4x4o4c> <div class="mb-4" data-astro-cid-4w4x4o4c> <p class="text-sm text-gray-300 sm:text-base" data-astro-cid-4w4x4o4c>\nAjusta los pesos objetivo, define si puedes comprar\n						fracciones y establece un presupuesto y un margen de\n						tolerancia para evitar rebalanceos excesivos.\n</p> </div> <form id="allocation-form" novalidate data-astro-cid-4w4x4o4c> <div class="mb-4 grid grid-cols-1 gap-3 sm:mb-6 sm:gap-4 md:grid-cols-2" data-astro-cid-4w4x4o4c> <div class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4" data-astro-cid-4w4x4o4c> <div class="mb-2 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between" data-astro-cid-4w4x4o4c> <label for="budget" class="block text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nDinero disponible (&euro;)\n</label> <div class="flex items-center gap-2" data-astro-cid-4w4x4o4c> <span class="text-xs text-gray-400 sm:text-sm" data-astro-cid-4w4x4o4c>Permitir traspasos</span> <button type="button" id="allow-transfers" role="switch" aria-checked="false" aria-label="Permitir ventas para rebalancear" class="relative inline-flex h-7 w-12 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-5 w-5 translate-x-1 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> </div> <input id="budget" name="budget" type="number" min="0" step="0.01" placeholder="Ej. 500" class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> <small class="mt-2 block text-xs text-blue-400" data-astro-cid-4w4x4o4c>\nD\xE9jalo vac\xEDo para obtener la aportaci\xF3n m\xEDnima\n								sin l\xEDmite.\n</small> </div> <div class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-4" data-astro-cid-4w4x4o4c> <label for="margin" class="mb-2 block text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nMargen de error (+/- %)\n</label> <input id="margin" name="margin" type="number" min="0" max="20" step="0.1" value="1" class="w-full rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> <small class="mt-2 block text-xs text-blue-400" data-astro-cid-4w4x4o4c>\nEvita perseguir el porcentaje exacto; permite\n								una banda segura.\n</small> </div> </div> <div class="mb-4 rounded-lg border border-gray-700 bg-gray-800/50 p-4 sm:mb-6 sm:p-5" data-astro-cid-4w4x4o4c> <div class="mb-3 flex flex-col gap-2 sm:mb-4 sm:flex-row sm:items-center sm:justify-between" data-astro-cid-4w4x4o4c> <h2 class="text-lg font-semibold text-gray-100 sm:text-xl" data-astro-cid-4w4x4o4c>\nReparto actual\n</h2> <span id="current-total-label" class="text-base font-bold text-blue-400 sm:text-lg" data-astro-cid-4w4x4o4c>-</span> </div> <ul id="current-distribution" class="grid grid-cols-1 gap-2 sm:grid-cols-2 lg:grid-cols-3" data-astro-cid-4w4x4o4c> <li class="rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400" data-astro-cid-4w4x4o4c>\nIntroduce los valores actuales para ver el\n								reparto porcentual.\n</li> </ul> </div> <div class="mb-4 space-y-3 sm:mb-6 sm:space-y-4" id="rows-container" data-astro-cid-4w4x4o4c> ', ' </div> <button type="button" id="add-row-btn" class="mb-3 rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:mb-4 sm:px-6" data-astro-cid-4w4x4o4c>\n+ A\xF1adir activo\n</button> <p class="mb-4 text-sm text-gray-400" data-astro-cid-4w4x4o4c>\nActiva el toggle cuando solo puedas comprar unidades\n						completas; el campo de precio se habilitar\xE1\n						autom\xE1ticamente. Los c\xE1lculos se actualizan en tiempo\n						real.\n</p> <div class="flex flex-wrap gap-2" data-astro-cid-4w4x4o4c> <button id="reset-btn" type="button" class="rounded-md border border-gray-600 bg-gray-700 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-gray-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nRestablecer\n</button> <button id="export-btn" type="button" class="rounded-md border border-blue-600 bg-blue-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-blue-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nExportar\n</button> <button id="import-btn" type="button" class="rounded-md border border-green-600 bg-green-700 px-4 py-2 text-sm font-medium text-gray-100 transition-colors hover:bg-green-600 sm:px-8 sm:py-3" data-astro-cid-4w4x4o4c>\nImportar\n</button> <input type="file" id="import-file" accept=".json" class="hidden" data-astro-cid-4w4x4o4c> </div> <template id="row-template" data-astro-cid-4w4x4o4c> <div class="relative rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-md sm:p-4" data-row data-astro-cid-4w4x4o4c> <button type="button" data-action="delete-row" class="absolute top-2 right-2 rounded-md p-1.5 text-gray-400 transition-colors hover:bg-red-600/20 hover:text-red-400 focus:ring-2 focus:ring-red-500 focus:outline-none" title="Eliminar activo" data-astro-cid-4w4x4o4c> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" data-astro-cid-4w4x4o4c> <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" data-astro-cid-4w4x4o4c></path> </svg> </button> <div class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-8" data-astro-cid-4w4x4o4c> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nISIN\n</label> <input data-field="isin" type="text" placeholder="ES0123456789" class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2 lg:col-span-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nActivo\n</label> <input data-field="name" type="text" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nValor actual (&euro;)\n</label> <input data-field="current" type="number" min="0" step="0.01" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-price-wrapper data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nPrecio unidad (&euro;)\n</label> <input data-field="price" type="number" min="0" step="0.01" disabled class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\n\xBFSolo unidades completas?\n</label> <button type="button" role="switch" data-field="whole" aria-checked="false" aria-label="Activar unidades completas" class="relative inline-flex h-8 w-14 items-center rounded-full bg-gray-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-6 w-6 translate-x-1 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nObjetivo (%)\n</label> <input data-field="target" type="number" min="0" max="100" step="0.1" required class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>\nIncluir en c\xE1lculo\n</label> <button type="button" role="switch" data-field="included" aria-checked="true" aria-label="Incluir en el c\xE1lculo" class="relative inline-flex h-8 w-14 items-center rounded-full bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none" data-astro-cid-4w4x4o4c> <span class="inline-block h-6 w-6 translate-x-7 transform rounded-full bg-white transition-transform" data-astro-cid-4w4x4o4c></span> </button> </div> </div> </div> </template> </form> <div id="results" class="mt-4 space-y-4 sm:mt-6 sm:space-y-6" hidden data-astro-cid-4w4x4o4c> <div id="summary" class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-3" data-astro-cid-4w4x4o4c></div> <p id="advice" class="rounded-lg border border-blue-500/30 bg-blue-950/30 p-3 text-sm text-gray-200 sm:p-4 sm:text-base" data-astro-cid-4w4x4o4c></p> <div class="overflow-x-auto rounded-lg border border-gray-700 bg-gray-800" data-astro-cid-4w4x4o4c> <table class="w-full" data-astro-cid-4w4x4o4c> <thead class="border-b border-gray-700 bg-gray-900" data-astro-cid-4w4x4o4c> <tr data-astro-cid-4w4x4o4c> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Activo</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Actual</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Objetivo</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Aportar</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>\nTu aportaci\xF3n\n</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>Unid.</th> <th class="px-3 py-2 text-left text-xs font-medium text-gray-300 sm:px-4 sm:py-3 sm:text-sm" data-astro-cid-4w4x4o4c>% final</th> </tr> </thead> <tbody id="results-body" class="divide-y divide-gray-700" data-astro-cid-4w4x4o4c></tbody> </table> </div> <div id="step-guide" class="rounded-lg border border-gray-700 bg-gray-800 p-4 sm:p-6" data-astro-cid-4w4x4o4c> <h3 class="mb-4 text-lg font-semibold text-gray-100 sm:text-xl" data-astro-cid-4w4x4o4c>\nPaso a paso\n</h3> <ol id="step-list" class="space-y-3 text-sm text-gray-300 sm:text-base" data-astro-cid-4w4x4o4c></ol> </div> </div> <p id="error" class="mt-4 rounded-lg border border-red-500/50 bg-red-950/30 p-3 text-sm text-red-400 sm:mt-6 sm:p-4" role="alert" hidden data-astro-cid-4w4x4o4c></p> </div> </div> </div> <script type="module">', "\n		const initialAssets = defaultAssets;\n		const form = document.querySelector('#allocation-form');\n		const rowsContainer = document.querySelector('#rows-container');\n		const rowTemplate = document.querySelector('#row-template');\n		const addRowBtn = document.querySelector('#add-row-btn');\n		const budgetInput = document.querySelector('#budget');\n		const marginInput = document.querySelector('#margin');\n		const transfersToggle = document.querySelector('#allow-transfers');\n		const distributionList = document.querySelector(\n			'#current-distribution'\n		);\n		const currentTotalLabel = document.querySelector(\n			'#current-total-label'\n		);\n		const resultsSection = document.querySelector('#results');\n		const summaryEl = document.querySelector('#summary');\n		const adviceEl = document.querySelector('#advice');\n		const tbody = document.querySelector('#results-body');\n		const stepGuide = document.querySelector('#step-guide');\n		const stepList = document.querySelector('#step-list');\n		const errorBox = document.querySelector('#error');\n		const resetBtn = document.querySelector('#reset-btn');\n		const exportBtn = document.querySelector('#export-btn');\n		const importBtn = document.querySelector('#import-btn');\n		const importFileInput = document.querySelector('#import-file');\n\n		const numberFormatter = new Intl.NumberFormat('es-ES', {\n			style: 'currency',\n			currency: 'EUR',\n			minimumFractionDigits: 2,\n		});\n\n		const percentFormatter = new Intl.NumberFormat('es-ES', {\n			style: 'percent',\n			minimumFractionDigits: 2,\n			maximumFractionDigits: 2,\n		});\n\n		const unitFormatter = new Intl.NumberFormat('es-ES', {\n			minimumFractionDigits: 2,\n			maximumFractionDigits: 4,\n		});\n\n		const marginNumberFormatter = new Intl.NumberFormat('es-ES', {\n			minimumFractionDigits: 0,\n			maximumFractionDigits: 2,\n		});\n\n		const clamp = (value, min = 0, max = 1) =>\n			Math.min(Math.max(value, min), max);\n\n		const sanitize = (value) => {\n			if (typeof value !== 'string') return 0;\n			return Number(value.replace(',', '.')) || 0;\n		};\n\n		// Funci\xF3n para refrescar todos los precios de ISINs en el formulario\n		const refreshAllPrices = () => {\n			const rows = rowsContainer.querySelectorAll('[data-row]');\n			rows.forEach((row) => {\n				const isinInput = row.querySelector('[data-field=\"isin\"]');\n				const priceInput = row.querySelector('[data-field=\"price\"]');\n				const wholeToggle = row.querySelector('[data-field=\"whole\"]');\n\n				const isin = isinInput?.value?.trim().toUpperCase();\n				const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;\n\n				// Solo intentar si hay un ISIN v\xE1lido\n				if (\n					isin &&\n					isinRegex.test(isin) &&\n					isinInput &&\n					priceInput &&\n					wholeToggle\n				) {\n					const isETF =\n						wholeToggle.getAttribute('aria-checked') === 'true';\n					// A\xF1adir un peque\xF1o delay entre requests para no sobrecargar\n					setTimeout(() => {\n						fetchPriceByISIN(isin, priceInput, isinInput, isETF);\n					}, Math.random() * 1000); // Random delay 0-1s\n				}\n			});\n		};\n\n		// Funci\xF3n para obtener el precio de un fondo por ISIN\n		const fetchPriceByISIN = async (isin, priceInput, isinInput, isETF) => {\n			// Validar que el ISIN no est\xE9 vac\xEDo\n			if (!isin || isin.trim().length === 0) {\n				console.warn('ISIN vac\xEDo o inv\xE1lido:', isin);\n				return;\n			}\n\n			// Mostrar estado de carga\n			isinInput.classList.remove('border-yellow-500', 'border-green-500');\n			isinInput.classList.add('border-blue-500');\n			isinInput.title = 'Buscando precio...';\n\n			try {\n				// Normalizar ISIN antes de enviarlo\n				const normalizedIsin = isin.trim().toUpperCase();\n\n				// Construir URL con query params\n				const params = new URLSearchParams();\n				params.set('isin', normalizedIsin);\n				params.set('isETF', isETF ? 'true' : 'false');\n				const apiUrl = \\`/api/fund-price?\\${params.toString()}\\`;\n\n				// Llamar al endpoint API de Astro que hace el fetch desde el servidor\n				// Esto evita problemas de CORS mediante web scraping\n				const response = await fetch(apiUrl, {\n					method: 'GET',\n					headers: {\n						Accept: 'application/json',\n					},\n				});\n\n				if (!response.ok) {\n					const errorData = await response.json().catch(() => ({}));\n					throw new Error(\n						errorData.message || 'No se pudo obtener el precio'\n					);\n				}\n\n				const data = await response.json();\n\n				if (data.price && data.price > 0) {\n					// Precio obtenido exitosamente\n					priceInput.value = data.price.toFixed(4);\n\n					// Actualizar el nombre si viene en la respuesta\n					if (data.name) {\n						const row = priceInput.closest('[data-row]');\n						const nameInput = row.querySelector(\n							'[data-field=\"name\"]'\n						);\n						// Solo actualizar si est\xE1 vac\xEDo o es un nombre gen\xE9rico\n						if (\n							!nameInput.value ||\n							nameInput.value.startsWith('Activo ')\n						) {\n							nameInput.value = data.name;\n						}\n					}\n\n					// Habilitar el campo de precio si el toggle est\xE1 activado\n					const row = priceInput.closest('[data-row]');\n					const wholeToggle = row.querySelector(\n						'[data-field=\"whole\"]'\n					);\n					if (wholeToggle.getAttribute('aria-checked') === 'true') {\n						priceInput.disabled = false;\n					}\n\n					// Actualizar estilos\n					isinInput.classList.remove('border-blue-500');\n					isinInput.classList.add('border-green-500');\n					isinInput.title = 'Precio obtenido correctamente';\n\n					// Actualizar c\xE1lculos\n					saveFormState();\n					updateCurrentDistribution();\n					autoCalculate();\n				} else {\n					throw new Error(data.message || 'Precio no disponible');\n				}\n			} catch (error) {\n				// Si falla, mostrar mensaje al usuario\n				console.warn('Error al obtener precio por ISIN:', error);\n\n				isinInput.classList.remove('border-blue-500');\n				isinInput.classList.add('border-yellow-500');\n				isinInput.title =\n					'No se pudo obtener el precio autom\xE1ticamente. Introd\xFAcelo manualmente en el campo \"Precio unidad\".';\n\n				// Habilitar el campo de precio para entrada manual si el toggle est\xE1 activado\n				const row = priceInput.closest('[data-row]');\n				const wholeToggle = row.querySelector('[data-field=\"whole\"]');\n				if (wholeToggle.getAttribute('aria-checked') === 'true') {\n					priceInput.disabled = false;\n					priceInput.focus();\n				}\n			}\n		};\n\n		const getMarginValue = () => {\n			const raw = marginInput.value.trim();\n			const fallback = raw === '' ? 1 : sanitize(raw);\n			return Math.max(0, fallback);\n		};\n\n		const getMarginFraction = () => getMarginValue() / 100;\n\n		const setTransfersToggle = (enabled) => {\n			const state = Boolean(enabled);\n			transfersToggle.setAttribute('aria-checked', state);\n			if (state) {\n				transfersToggle.classList.remove('bg-gray-600');\n				transfersToggle.classList.add('bg-blue-600');\n				transfersToggle\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				transfersToggle\n					.querySelector('span')\n					.classList.add('translate-x-6');\n			} else {\n				transfersToggle.classList.remove('bg-blue-600');\n				transfersToggle.classList.add('bg-gray-600');\n				transfersToggle\n					.querySelector('span')\n					.classList.remove('translate-x-6');\n				transfersToggle\n					.querySelector('span')\n					.classList.add('translate-x-1');\n			}\n		};\n\n		const transfersEnabled = () =>\n			transfersToggle.getAttribute('aria-checked') === 'true';\n\n		const initializeRow = (row, data = {}) => {\n			const inputMap = {\n				name: row.querySelector('[data-field=\"name\"]'),\n				isin: row.querySelector('[data-field=\"isin\"]'),\n				current: row.querySelector('[data-field=\"current\"]'),\n				price: row.querySelector('[data-field=\"price\"]'),\n				target: row.querySelector('[data-field=\"target\"]'),\n				whole: row.querySelector('[data-field=\"whole\"]'),\n				included: row.querySelector('[data-field=\"included\"]'),\n			};\n\n			if (data.name) inputMap.name.value = data.name;\n			if (data.isin) inputMap.isin.value = data.isin;\n			if (typeof data.current !== 'undefined')\n				inputMap.current.value = data.current;\n			if (typeof data.price !== 'undefined' && data.price !== 0)\n				inputMap.price.value = data.price;\n			if (typeof data.target !== 'undefined')\n				inputMap.target.value = data.target;\n\n			// Inicializar estado del toggle de unidades completas\n			const isChecked = Boolean(data.wholeUnits);\n			inputMap.whole.setAttribute('aria-checked', isChecked);\n			if (isChecked) {\n				inputMap.whole.classList.remove('bg-gray-600');\n				inputMap.whole.classList.add('bg-blue-600');\n				inputMap.whole\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				inputMap.whole\n					.querySelector('span')\n					.classList.add('translate-x-7');\n			}\n\n			// Inicializar estado del toggle de inclusi\xF3n en c\xE1lculo\n			const isIncluded =\n				typeof data.includedInCalculation === 'undefined'\n					? true\n					: Boolean(data.includedInCalculation);\n			inputMap.included.setAttribute('aria-checked', isIncluded);\n			if (isIncluded) {\n				inputMap.included.classList.remove('bg-gray-600');\n				inputMap.included.classList.add('bg-blue-600');\n				inputMap.included\n					.querySelector('span')\n					.classList.remove('translate-x-1');\n				inputMap.included\n					.querySelector('span')\n					.classList.add('translate-x-7');\n			} else {\n				inputMap.included.classList.remove('bg-blue-600');\n				inputMap.included.classList.add('bg-gray-600');\n				inputMap.included\n					.querySelector('span')\n					.classList.remove('translate-x-7');\n				inputMap.included\n					.querySelector('span')\n					.classList.add('translate-x-1');\n			}\n\n			const updatePriceState = () => {\n				const enabled =\n					inputMap.whole.getAttribute('aria-checked') === 'true';\n				inputMap.price.disabled = !enabled;\n				inputMap.price.required = enabled;\n			};\n\n			// Manejar click en el toggle\n			inputMap.whole.addEventListener('click', () => {\n				const isChecked =\n					inputMap.whole.getAttribute('aria-checked') === 'true';\n				const newState = !isChecked;\n\n				inputMap.whole.setAttribute('aria-checked', newState);\n				if (newState) {\n					inputMap.whole.classList.remove('bg-gray-600');\n					inputMap.whole.classList.add('bg-blue-600');\n					inputMap.whole\n						.querySelector('span')\n						.classList.remove('translate-x-1');\n					inputMap.whole\n						.querySelector('span')\n						.classList.add('translate-x-7');\n				} else {\n					inputMap.whole.classList.remove('bg-blue-600');\n					inputMap.whole.classList.add('bg-gray-600');\n					inputMap.whole\n						.querySelector('span')\n						.classList.remove('translate-x-7');\n					inputMap.whole\n						.querySelector('span')\n						.classList.add('translate-x-1');\n				}\n\n				updatePriceState();\n				saveFormState();\n				autoCalculate();\n			});\n\n			updatePriceState();\n\n			// Manejar click en el toggle de inclusi\xF3n\n			inputMap.included.addEventListener('click', () => {\n				const isChecked =\n					inputMap.included.getAttribute('aria-checked') === 'true';\n				const newState = !isChecked;\n\n				inputMap.included.setAttribute('aria-checked', newState);\n				if (newState) {\n					inputMap.included.classList.remove('bg-gray-600');\n					inputMap.included.classList.add('bg-blue-600');\n					inputMap.included\n						.querySelector('span')\n						.classList.remove('translate-x-1');\n					inputMap.included\n						.querySelector('span')\n						.classList.add('translate-x-7');\n				} else {\n					inputMap.included.classList.remove('bg-blue-600');\n					inputMap.included.classList.add('bg-gray-600');\n					inputMap.included\n						.querySelector('span')\n						.classList.remove('translate-x-7');\n					inputMap.included\n						.querySelector('span')\n						.classList.add('translate-x-1');\n				}\n\n				saveFormState();\n				updateCurrentDistribution();\n				autoCalculate();\n			});\n\n			// Manejar cambios en el campo ISIN\n			let isinTimeout;\n			inputMap.isin.addEventListener('input', (e) => {\n				const isinValue = inputMap.isin.value.trim().toUpperCase();\n				clearTimeout(isinTimeout);\n\n				if (isinValue.length >= 12) {\n					// Validar formato ISIN b\xE1sico (12 caracteres)\n					const isinRegex = /^[A-Z]{2}[A-Z0-9]{9}[0-9]$/;\n					if (isinRegex.test(isinValue)) {\n						// Mostrar indicador de carga\n						inputMap.isin.classList.add('border-blue-500');\n						inputMap.price.disabled = true;\n\n						// Capturar los elementos en el closure\n						const priceInput = inputMap.price;\n						const isinInput = inputMap.isin;\n\n						isinTimeout = setTimeout(() => {\n							// Verificar que el valor no haya cambiado\n							const currentIsin = isinInput.value\n								.trim()\n								.toUpperCase();\n\n							if (\n								currentIsin === isinValue &&\n								isinRegex.test(currentIsin)\n							) {\n								// Obtener el estado del toggle de unidades completas\n								const row = isinInput.closest('[data-row]');\n								const wholeToggle = row.querySelector(\n									'[data-field=\"whole\"]'\n								);\n								const isETF =\n									wholeToggle.getAttribute('aria-checked') ===\n									'true';\n\n								fetchPriceByISIN(\n									currentIsin,\n									priceInput,\n									isinInput,\n									isETF\n								);\n							}\n						}, 800); // Debounce de 800ms\n					}\n				} else {\n					inputMap.isin.classList.remove('border-blue-500');\n				}\n\n				saveFormState();\n			});\n\n			row.querySelectorAll('input').forEach((input) => {\n				if (input !== inputMap.isin) {\n					input.addEventListener('input', () => {\n						window.requestAnimationFrame(updateCurrentDistribution);\n						saveFormState();\n						autoCalculate();\n					});\n				}\n			});\n\n			// Manejar el bot\xF3n de eliminar\n			const deleteBtn = row.querySelector('[data-action=\"delete-row\"]');\n			if (deleteBtn) {\n				deleteBtn.addEventListener('click', () => {\n					deleteRow(row);\n				});\n			}\n		};\n\n		const initialRows = rowsContainer.querySelectorAll('[data-row]');\n		initialRows.forEach((row, index) =>\n			initializeRow(row, initialAssets[index] ?? {})\n		);\n\n		const createRow = () => {\n			const fragment = rowTemplate.content.cloneNode(true);\n			const row = fragment.querySelector('[data-row]');\n			rowsContainer.appendChild(fragment);\n			initializeRow(row);\n			updateCurrentDistribution();\n			saveFormState();\n		};\n\n		const deleteRow = (row) => {\n			const allRows = rowsContainer.querySelectorAll('[data-row]');\n\n			// Si es la \xFAnica fila, eliminarla y crear una vac\xEDa\n			if (allRows.length === 1) {\n				row.remove();\n				createRow();\n			} else {\n				// Si hay m\xE1s filas, simplemente eliminar\n				row.remove();\n			}\n\n			updateCurrentDistribution();\n			saveFormState();\n			autoCalculate();\n		};\n\n		addRowBtn.addEventListener('click', createRow);\n\n		transfersToggle.addEventListener('click', () => {\n			const current = transfersEnabled();\n			setTransfersToggle(!current);\n			saveFormState();\n			autoCalculate();\n		});\n\n		const getRows = ({ strict = true } = {}) =>\n			[...rowsContainer.querySelectorAll('[data-row]')].map(\n				(row, index) => {\n					const nameField = row.querySelector('[data-field=\"name\"]');\n					const isinField = row.querySelector('[data-field=\"isin\"]');\n					const currentField = row.querySelector(\n						'[data-field=\"current\"]'\n					);\n					const priceField = row.querySelector(\n						'[data-field=\"price\"]'\n					);\n					const targetField = row.querySelector(\n						'[data-field=\"target\"]'\n					);\n					const wholeToggle = row.querySelector(\n						'[data-field=\"whole\"]'\n					);\n					const includedToggle = row.querySelector(\n						'[data-field=\"included\"]'\n					);\n\n					const name =\n						nameField.value.trim() || \\`Activo \\${index + 1}\\`;\n					const isin = isinField.value.trim().toUpperCase() || null;\n					const current = sanitize(currentField.value);\n					const target = sanitize(targetField.value);\n					const wholeUnits =\n						wholeToggle.getAttribute('aria-checked') === 'true';\n					const includedInCalculation =\n						includedToggle.getAttribute('aria-checked') === 'true';\n					const price = wholeUnits\n						? sanitize(priceField.value)\n						: sanitize(priceField.value) || 0;\n\n					if (strict) {\n						if (current < 0 || target < 0) {\n							throw new Error(\n								'Los importes y objetivos deben ser iguales o mayores que 0.'\n							);\n						}\n\n						if (wholeUnits && price <= 0) {\n							throw new Error(\n								\\`Define un precio por unidad v\xE1lido para \\${name}.\\`\n							);\n						}\n					}\n\n					return {\n						name,\n						isin,\n						current,\n						price: price > 0 ? price : 0,\n						target,\n						wholeUnits,\n						includedInCalculation,\n					};\n				}\n			);\n\n		const updateCurrentDistribution = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const totalAll = rows.reduce(\n					(sum, asset) => sum + asset.current,\n					0\n				);\n				const includedRows = rows.filter(\n					(asset) => asset.includedInCalculation\n				);\n				const totalIncluded = includedRows.reduce(\n					(sum, asset) => sum + asset.current,\n					0\n				);\n\n				if (totalAll <= 0) {\n					currentTotalLabel.textContent = '-';\n					distributionList.innerHTML =\n						'<li class=\"rounded-lg border border-dashed border-gray-600 bg-gray-700/30 px-3 py-2 text-sm text-gray-400\">Introduce los importes para ver el reparto.</li>';\n					return;\n				}\n\n				// Mostrar dos totales: todos y solo incluidos\n				if (totalIncluded !== totalAll) {\n					currentTotalLabel.innerHTML = \\`\n						<div class=\"flex flex-col gap-1\">\n							<span>Total: \\${numberFormatter.format(totalAll)}</span>\n							<span class=\"text-sm text-blue-300\">Incluidos: \\${numberFormatter.format(totalIncluded)}</span>\n						</div>\n					\\`;\n				} else {\n					currentTotalLabel.textContent =\n						numberFormatter.format(totalAll);\n				}\n\n				// Mostrar todos los activos, pero marcar visualmente los excluidos\n				const allRowElements = Array.from(\n					rowsContainer.querySelectorAll('[data-row]')\n				);\n				distributionList.innerHTML = rows\n					.map((asset, index) => {\n						// Obtener el nombre real del campo de la fila correspondiente\n						const rowElement = allRowElements[index];\n						const nameField = rowElement?.querySelector(\n							'[data-field=\"name\"]'\n						);\n						// Usar el valor del campo si existe, sino el nombre del asset\n						const displayName =\n							nameField?.value?.trim() || asset.name;\n						const isIncluded = asset.includedInCalculation;\n						const opacity = isIncluded ? '' : 'opacity-50';\n						const totalForPercent = isIncluded\n							? totalIncluded\n							: totalAll;\n\n						return \\`\n							<li class=\"flex items-center justify-between rounded-lg border border-gray-700 bg-gray-700/50 px-3 py-2 text-sm \\${opacity}\">\n								<strong class=\"text-gray-200\">\\${displayName}</strong>\n								<span class=\"font-medium text-blue-400\">\\${percentFormatter.format(asset.current / totalForPercent)}</span>\n							</li>\n						\\`;\n					})\n					.join('');\n			} catch (error) {\n				// Ignorar errores en modo no estricto\n			}\n		};\n\n		updateCurrentDistribution();\n\n		const normalizeTargets = (assets, marginFraction) => {\n			const sumTargets = assets.reduce(\n				(sum, asset) => sum + asset.target,\n				0\n			);\n			if (sumTargets <= 0) {\n				throw new Error('La suma de objetivos debe ser mayor que 0 %.');\n			}\n\n			return assets.map((asset) => {\n				const weight = asset.target / sumTargets;\n				const minShare = clamp(weight - marginFraction, 0, 1);\n				const maxShare = clamp(weight + marginFraction, 0, 1);\n				if (maxShare <= 0 && asset.current > 0) {\n					throw new Error(\n						\\`El margen no permite mantener \\${asset.name} sin vender.\\`\n					);\n				}\n				return { ...asset, weight, minShare, maxShare };\n			});\n		};\n\n		const projectToBounds = (targets, mins, maxs, total) => {\n			const minSum = mins.reduce((sum, value) => sum + value, 0);\n			const maxSum = maxs.reduce((sum, value) => sum + value, 0);\n\n			if (total < minSum - 1e-6) {\n				throw new Error(\n					'El presupuesto disponible es insuficiente para respetar los m\xEDnimos dentro del margen.'\n				);\n			}\n\n			if (total > maxSum + 1e-6) {\n				throw new Error(\n					'Los objetivos y el margen no permiten usar todo el presupuesto sin sobrepasar l\xEDmites.'\n				);\n			}\n\n			const allocations = targets.map((value, index) =>\n				clamp(value, mins[index], maxs[index])\n			);\n\n			for (let i = 0; i < 80; i++) {\n				const currentTotal = allocations.reduce(\n					(sum, value) => sum + value,\n					0\n				);\n				const diff = total - currentTotal;\n				if (Math.abs(diff) <= 1e-6) break;\n\n				const freeIndexes = allocations\n					.map((value, index) => ({ value, index }))\n					.filter(\n						(item) =>\n							item.value > mins[item.index] + 1e-9 &&\n							item.value < maxs[item.index] - 1e-9\n					);\n\n				if (!freeIndexes.length) break;\n\n				const share = diff / freeIndexes.length;\n				let adjusted = false;\n\n				freeIndexes.forEach((item) => {\n					let candidate = allocations[item.index] + share;\n					if (candidate < mins[item.index]) {\n						candidate = mins[item.index];\n						adjusted = true;\n					} else if (candidate > maxs[item.index]) {\n						candidate = maxs[item.index];\n						adjusted = true;\n					}\n					allocations[item.index] = candidate;\n				});\n\n				if (!adjusted && Math.abs(diff) <= 1e-6) break;\n			}\n\n			const finalTotal = allocations.reduce((sum, v) => sum + v, 0);\n			if (Math.abs(finalTotal - total) > 1e-4) {\n				throw new Error(\n					'No se pudo encontrar una distribuci\xF3n v\xE1lida con las restricciones actuales.'\n				);\n			}\n\n			return allocations;\n		};\n\n		const raiseGroupMinimums = (mins, maxs, groups) => {\n			let unresolved = 0;\n			groups.forEach((group) => {\n				const currentMin = group.indexes.reduce(\n					(sum, idx) => sum + mins[idx],\n					0\n				);\n				let deficit = group.required - currentMin;\n				let safety = 0;\n\n				while (deficit > 1e-6) {\n					safety += 1;\n					if (safety > 50) break;\n					const adjustable = group.indexes.filter(\n						(idx) => maxs[idx] - mins[idx] > 1e-9\n					);\n					if (!adjustable.length) {\n						unresolved += deficit;\n						break;\n					}\n					const totalRoom = adjustable.reduce(\n						(sum, idx) => sum + (maxs[idx] - mins[idx]),\n						0\n					);\n					if (totalRoom + 1e-6 < deficit) {\n						// Llevar todo a su m\xE1ximo posible\n						adjustable.forEach((idx) => {\n							mins[idx] = maxs[idx];\n						});\n						unresolved += deficit - totalRoom;\n						break;\n					}\n\n					adjustable.forEach((idx) => {\n						const room = maxs[idx] - mins[idx];\n						const addition = Math.min(\n							room,\n							(room / totalRoom) * deficit\n						);\n						mins[idx] += addition;\n					});\n\n					const newMin = group.indexes.reduce(\n						(sum, idx) => sum + mins[idx],\n						0\n					);\n					deficit = group.required - newMin;\n				}\n			});\n			return unresolved;\n		};\n\n		const computeWithTransfers = (assets, budget) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n\n			// PASO 1: Calcular asignaci\xF3n solo con traspasos (sin a\xF1adir dinero)\n			const transferTotal = currentTotal;\n			const transferMins = normalized.map(\n				(asset) => asset.minShare * transferTotal\n			);\n			const transferMaxs = normalized.map(\n				(asset) => asset.maxShare * transferTotal\n			);\n			const transferTargets = normalized.map(\n				(asset) => asset.weight * transferTotal\n			);\n\n			// ETFs no pueden venderse\n			normalized.forEach((asset, idx) => {\n				if (asset.wholeUnits) {\n					transferMins[idx] = Math.max(\n						transferMins[idx],\n						asset.current\n					);\n					transferMaxs[idx] = Math.max(\n						transferMaxs[idx],\n						asset.current\n					);\n				}\n			});\n\n			// Asegurar que maxs >= mins\n			normalized.forEach((asset, idx) => {\n				transferMaxs[idx] = Math.max(\n					transferMaxs[idx],\n					transferMins[idx]\n				);\n			});\n\n			// Verificar factibilidad antes de proyectar\n			const transferMinSum = transferMins.reduce((sum, v) => sum + v, 0);\n			if (transferMinSum > transferTotal + 1e-6) {\n				// Escalar m\xEDnimos proporcionalmente\n				const scale = transferTotal / transferMinSum;\n				normalized.forEach((asset, idx) => {\n					transferMins[idx] *= scale;\n					transferMaxs[idx] = Math.max(\n						transferMaxs[idx],\n						transferMins[idx]\n					);\n				});\n			}\n\n			const transferAllocations = projectToBounds(\n				transferTargets,\n				transferMins,\n				transferMaxs,\n				transferTotal\n			);\n\n			// Verificar si realmente hay ventas necesarias (alg\xFAn activo debe reducir su valor)\n			const hasSales = normalized.some(\n				(asset, idx) => transferAllocations[idx] < asset.current - 1e-6\n			);\n\n			// Si no hay ventas necesarias, usar la misma l\xF3gica que allocateWithBudget\n			if (!hasSales) {\n				return allocateWithBudget(assets, budget);\n			}\n\n			// PASO 2: Calcular m\xEDnimo dinero adicional necesario\n			const calcMinNeeded = () => {\n				let low = transferTotal;\n				let high = transferTotal * 3;\n\n				const feasible = (total) => {\n					try {\n						const mins = normalized.map(\n							(asset) => asset.minShare * total\n						);\n						const maxs = normalized.map(\n							(asset) => asset.maxShare * total\n						);\n						const targets = normalized.map(\n							(asset) => asset.weight * total\n						);\n\n						normalized.forEach((asset, idx) => {\n							if (asset.wholeUnits) {\n								mins[idx] = Math.max(mins[idx], asset.current);\n							} else {\n								mins[idx] = Math.max(\n									mins[idx],\n									transferAllocations[idx]\n								);\n							}\n						});\n\n						// Verificar si los m\xEDnimos son factibles\n						const minSum = mins.reduce((sum, v) => sum + v, 0);\n						if (minSum > total + 1e-6) {\n							return false;\n						}\n\n						// Asegurar que maxs >= mins\n						normalized.forEach((asset, idx) => {\n							maxs[idx] = Math.max(maxs[idx], mins[idx]);\n						});\n\n						const allocs = projectToBounds(\n							targets,\n							mins,\n							maxs,\n							total\n						);\n						const needed = normalized.reduce((sum, asset, idx) => {\n							const need = allocs[idx] - transferAllocations[idx];\n							return sum + Math.max(0, need);\n						}, 0);\n\n						return transferTotal + needed <= total + 1e-6;\n					} catch (e) {\n						return false;\n					}\n				};\n\n				for (let i = 0; i < 60; i++) {\n					const mid = (low + high) / 2;\n					if (feasible(mid)) {\n						high = mid;\n					} else {\n						low = mid;\n					}\n					if (high - low < 1e-6) break;\n				}\n				return high;\n			};\n\n			const minNeededTotal = calcMinNeeded();\n			const minNeededBudget = minNeededTotal - currentTotal;\n\n			// PASO 3: Determinar total final y asignaciones\n			let finalTotal;\n			let allocations;\n\n			if (budget <= 0) {\n				// Sin presupuesto: usar solo traspasos (sin a\xF1adir dinero)\n				finalTotal = currentTotal;\n				allocations = transferAllocations; // Usar directamente las asignaciones de traspasos\n			} else {\n				// Con presupuesto: combinar traspasos con compras\n				// Intentar usar todo el presupuesto disponible\n				const candidateTotal = currentTotal + budget;\n				// Si el candidato es mayor o igual al m\xEDnimo, usarlo\n				// De lo contrario, usar el m\xEDnimo (pero esto generar\xE1 un warning)\n				finalTotal = Math.max(candidateTotal, minNeededTotal);\n\n				// PASO 4: Calcular asignaci\xF3n final con presupuesto\n				const mins = normalized.map(\n					(asset) => asset.minShare * finalTotal\n				);\n				const maxs = normalized.map(\n					(asset) => asset.maxShare * finalTotal\n				);\n				const targets = normalized.map(\n					(asset) => asset.weight * finalTotal\n				);\n\n				// Establecer m\xEDnimos: ETFs no pueden bajar, fondos pueden bajar hasta lo que tienen tras traspasos\n				normalized.forEach((asset, idx) => {\n					if (asset.wholeUnits) {\n						mins[idx] = Math.max(mins[idx], asset.current);\n					} else {\n						// Fondos pueden vender hasta lo que tienen tras traspasos\n						const minFromTransfer = transferAllocations[idx];\n						mins[idx] = Math.max(mins[idx], minFromTransfer);\n					}\n				});\n\n				// Asegurar que la suma de m\xEDnimos no exceda el total\n				const minSum = mins.reduce((sum, v) => sum + v, 0);\n				if (minSum > finalTotal + 1e-6) {\n					// Escalar los m\xEDnimos de fondos proporcionalmente\n					const fixedSum = normalized.reduce(\n						(sum, asset, idx) =>\n							sum + (asset.wholeUnits ? mins[idx] : 0),\n						0\n					);\n					const availableForFonds = Math.max(\n						0,\n						finalTotal - fixedSum\n					);\n					const fondsMinSum = normalized.reduce(\n						(sum, asset, idx) =>\n							sum + (!asset.wholeUnits ? mins[idx] : 0),\n						0\n					);\n\n					if (fondsMinSum > 1e-6) {\n						const scale = availableForFonds / fondsMinSum;\n						normalized.forEach((asset, idx) => {\n							if (!asset.wholeUnits) {\n								mins[idx] *= scale;\n							}\n						});\n					}\n				}\n\n				// Asegurar que maxs >= mins\n				normalized.forEach((asset, idx) => {\n					maxs[idx] = Math.max(maxs[idx], mins[idx]);\n				});\n\n				allocations = projectToBounds(targets, mins, maxs, finalTotal);\n			}\n\n			const breakdown = normalized.map((asset, index) => {\n				const desired = allocations[index];\n				let addition = desired - asset.current;\n\n				if (asset.wholeUnits && addition < 0) {\n					addition = 0;\n				}\n\n				const units =\n					asset.price > 0 ? addition / asset.price : addition;\n				return { ...asset, desired, addition, units };\n			});\n\n			const buys = breakdown.reduce(\n				(sum, asset) => sum + Math.max(0, asset.addition),\n				0\n			);\n			const sells = breakdown.reduce(\n				(sum, asset) => sum + Math.max(0, -asset.addition),\n				0\n			);\n			const netSpent = buys - sells;\n\n			const providedBudget = budget > 0 ? budget : 0;\n\n			// Calcular cu\xE1nto dinero adicional se necesita despu\xE9s de los traspasos\n			const additionalNeeded = breakdown.reduce((sum, asset) => {\n				// Solo contar compras (addition > 0)\n				return sum + Math.max(0, asset.addition);\n			}, 0);\n\n			// Si hay presupuesto, el importe realmente usado es el m\xEDnimo entre netSpent y el presupuesto\n			// Si no hay presupuesto, es 0 (solo traspasos)\n			const actualNeeded =\n				providedBudget > 0 ? Math.min(netSpent, providedBudget) : 0;\n			// El dinero adicional necesario es el que se necesita para las compras\n			const extraNeeded =\n				budget <= 0\n					? additionalNeeded\n					: Math.max(0, netSpent - providedBudget);\n\n			let bestEffort = null;\n			let warning = null;\n\n			// Si no hay presupuesto y se necesita dinero adicional despu\xE9s de traspasos\n			if (budget <= 0 && extraNeeded > 1e-6) {\n				warning = {\n					type: 'additional_needed',\n					message: \\`Despu\xE9s de realizar los traspasos necesarios, se requiere aportar \\${numberFormatter.format(extraNeeded)} adicionales para alcanzar los objetivos dentro del margen.\\`,\n					minRequired: extraNeeded,\n				};\n			} else if (providedBudget > 0 && extraNeeded > 1e-6) {\n				const targetAdds = breakdown.map(\n					(asset) => asset.addition || 0\n				);\n				const totalNeeded = targetAdds.reduce(\n					(sum, val) => sum + Math.max(0, val),\n					0\n				);\n				const factor =\n					totalNeeded > 0\n						? Math.min(1, providedBudget / totalNeeded)\n						: 0;\n\n				const bestAlloc = normalized.map((asset, index) => {\n					const scaledAdd = Math.max(0, targetAdds[index]) * factor;\n					const desired = asset.current + scaledAdd;\n					const units =\n						asset.price > 0 ? scaledAdd / asset.price : scaledAdd;\n					return {\n						...asset,\n						desired,\n						addition: scaledAdd,\n						units,\n					};\n				});\n\n				bestEffort = {\n					breakdown: bestAlloc,\n					invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),\n				};\n\n				warning = {\n					type: 'insufficient',\n					message: \\`El presupuesto indicado (\\${numberFormatter.format(\n						providedBudget\n					)}) es insuficiente. Se necesitan al menos \\${numberFormatter.format(\n						netSpent\n					)} para alcanzar los m\xEDnimos dentro del margen establecido.\\`,\n					minRequired: netSpent,\n				};\n			}\n\n			return {\n				breakdown,\n				bestEffort,\n				totals: {\n					mode: providedBudget > 0 ? 'budget' : 'transfers',\n					currentTotal,\n					finalTotal,\n					budget: budget <= 0 ? additionalNeeded : providedBudget,\n					budgetProvided: providedBudget,\n					extraNeeded,\n					invested: budget <= 0 ? 0 : netSpent,\n					leftover: 0,\n					allowTransfers: true,\n				},\n				warning,\n			};\n		};\n\n		const ensureOverweightConstraint = (assets, total) =>\n			assets.every((asset) => {\n				if (asset.maxShare <= 0) {\n					return asset.current <= 1e-6;\n				}\n				return asset.current <= asset.maxShare * total + 1e-6;\n			});\n\n		const minimalContribution = (assets) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n\n			const minTotalFromOverweight = normalized.reduce((max, asset) => {\n				if (asset.maxShare <= 0) {\n					return asset.current <= 0 ? max : Infinity;\n				}\n				return Math.max(max, asset.current / asset.maxShare);\n			}, currentTotal);\n\n			let low = Math.max(currentTotal, minTotalFromOverweight);\n			let high = Number.isFinite(low) ? low : currentTotal + 1;\n\n			const requiredAddition = (total) =>\n				normalized.reduce((sum, asset) => {\n					const targetValue = asset.minShare * total;\n					return sum + Math.max(0, targetValue - asset.current);\n				}, 0);\n\n			const feasible = (total) => {\n				if (!Number.isFinite(total)) return false;\n				if (!ensureOverweightConstraint(normalized, total))\n					return false;\n				const additions = requiredAddition(total);\n				return currentTotal + additions <= total + 1e-6;\n			};\n\n			if (!feasible(high)) {\n				while (!feasible(high)) {\n					high *= 2;\n					if (high > 1e12) {\n						throw new Error(\n							'No se puede alcanzar la distribuci\xF3n con el margen indicado.'\n						);\n					}\n				}\n			}\n\n			for (let i = 0; i < 60; i++) {\n				const mid = (low + high) / 2;\n				if (feasible(mid)) {\n					high = mid;\n				} else {\n					low = mid;\n				}\n			}\n\n			const finalTotal = high;\n			const breakdown = normalized.map((asset) => {\n				const desired = Math.max(\n					asset.current,\n					asset.minShare * finalTotal\n				);\n				const addition = Math.max(0, desired - asset.current);\n				const units = asset.price > 0 ? addition / asset.price : 0;\n				return { ...asset, desired, addition, units };\n			});\n\n			const invested = breakdown.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n			return {\n				breakdown,\n				totals: {\n					mode: 'minimal',\n					currentTotal,\n					finalTotal,\n					invested,\n				},\n			};\n		};\n\n		const allocateWithBudget = (assets, budget) => {\n			const marginFraction = getMarginFraction();\n			const normalized = normalizeTargets(assets, marginFraction);\n			const currentTotal = normalized.reduce(\n				(sum, asset) => sum + asset.current,\n				0\n			);\n			const finalTotal = currentTotal + budget;\n\n			let warning = null;\n			let minimalResult = null;\n			let isOverweight = false;\n\n			// Verificar si hay activos sobreponderados\n			if (!ensureOverweightConstraint(normalized, finalTotal)) {\n				// Calcular el m\xEDnimo necesario (lo ideal)\n				minimalResult = minimalContribution(assets);\n				warning = {\n					type: 'overweight',\n					message: \\`\u26A0\uFE0F Con el presupuesto actual (\\${numberFormatter.format(budget)}) algunos activos quedar\xEDan sobreponderados. Se necesitar\xEDan al menos \\${numberFormatter.format(minimalResult.totals.invested)} para mantener el balance dentro del margen.\\`,\n					minRequired: minimalResult.totals.invested,\n				};\n				isOverweight = true;\n			}\n\n			// Calcular l\xEDmites: si un activo est\xE1 sobreponderado, no puede crecer ni bajar\n			const lowerBounds = normalized.map((asset) => {\n				const maxFromMargin = asset.maxShare * finalTotal;\n				// Si el activo est\xE1 sobreponderado, no puede bajar (su m\xEDnimo es su valor actual)\n				if (asset.current > maxFromMargin + 1e-6) {\n					return asset.current;\n				}\n				return Math.max(asset.current, asset.minShare * finalTotal);\n			});\n			const upperBounds = normalized.map((asset, index) => {\n				const maxFromMargin = asset.maxShare * finalTotal;\n				// Si el activo ya est\xE1 sobreponderado, su m\xE1ximo es su valor actual\n				if (asset.current > maxFromMargin + 1e-6) {\n					return asset.current;\n				}\n				return Math.max(lowerBounds[index], maxFromMargin);\n			});\n\n			const sumLower = lowerBounds.reduce((sum, value) => sum + value, 0);\n			if (sumLower - finalTotal > 1e-6) {\n				const minRequired = sumLower - currentTotal;\n				warning = {\n					type: 'insufficient',\n					message: \\`\u26A0\uFE0F El presupuesto indicado (\\${numberFormatter.format(budget)}) es insuficiente. Se necesitan al menos \\${numberFormatter.format(minRequired)} para alcanzar los m\xEDnimos dentro del margen establecido.\\`,\n					minRequired: minRequired,\n				};\n			}\n\n			let allocations = [...lowerBounds];\n			let remaining = finalTotal - sumLower;\n\n			let flex = normalized\n				.map((asset, index) => ({\n					index,\n					capacity: upperBounds[index] - allocations[index],\n				}))\n				.filter((item) => item.capacity > 1e-6);\n\n			while (flex.length && remaining > 1e-6) {\n				const weightSum = flex.reduce(\n					(sum, item) => sum + normalized[item.index].weight,\n					0\n				);\n				if (weightSum <= 0) break;\n\n				let consumed = 0;\n				const nextFlex = [];\n\n				flex.forEach((item) => {\n					const asset = normalized[item.index];\n					const share = (asset.weight / weightSum) * remaining;\n					if (share >= item.capacity - 1e-9) {\n						allocations[item.index] += item.capacity;\n						consumed += item.capacity;\n					} else {\n						allocations[item.index] += share;\n						consumed += share;\n						nextFlex.push({\n							index: item.index,\n							capacity: item.capacity - share,\n						});\n					}\n				});\n\n				if (consumed <= 1e-9) break;\n				remaining -= consumed;\n				flex = nextFlex;\n			}\n\n			const leftover = Math.max(0, remaining);\n\n			const breakdown = normalized.map((asset, index) => {\n				const desired = allocations[index];\n				const addition = Math.max(0, desired - asset.current);\n				const units = asset.price > 0 ? addition / asset.price : 0;\n				return { ...asset, desired, addition, units };\n			});\n\n			const invested = breakdown.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n\n			let bestEffort = null;\n			if (warning && warning.type === 'insufficient') {\n				const targetAdds = breakdown.map(\n					(asset) => asset.addition || 0\n				);\n				const totalNeeded = targetAdds.reduce(\n					(sum, val) => sum + val,\n					0\n				);\n				const factor =\n					totalNeeded > 0 ? Math.min(1, budget / totalNeeded) : 0;\n\n				const bestAlloc = normalized.map((asset, index) => {\n					const scaledAdd = targetAdds[index] * factor;\n					const desired = asset.current + scaledAdd;\n					const units =\n						asset.price > 0 ? scaledAdd / asset.price : scaledAdd;\n					return {\n						...asset,\n						desired,\n						addition: scaledAdd,\n						units,\n					};\n				});\n\n				bestEffort = {\n					breakdown: bestAlloc,\n					invested: bestAlloc.reduce((sum, a) => sum + a.addition, 0),\n				};\n			}\n\n			// Si hay sobreponderaci\xF3n, intercambiar breakdown y bestEffort\n			// breakdown principal = lo ideal (minimalResult)\n			// bestEffort = lo que realmente se puede hacer con el presupuesto disponible\n			// (distribuyendo el presupuesto sin exceder los m\xE1ximos)\n			if (isOverweight && minimalResult) {\n				// Calcular un bestEffort que respete los l\xEDmites m\xE1ximos y use exactamente el presupuesto\n				const safeFinalTotal = currentTotal + budget;\n\n				// L\xEDmites m\xEDnimos: no bajar de lo actual\n				const safeMins = normalized.map((asset) => asset.current);\n\n				// L\xEDmites m\xE1ximos: respetar el m\xE1ximo del margen en el total final\n				// Si un activo ya est\xE1 sobreponderado, su m\xE1ximo es su valor actual\n				const safeMaxs = normalized.map((asset, idx) => {\n					const maxFromMargin = asset.maxShare * safeFinalTotal;\n					// Si el activo ya est\xE1 por encima del m\xE1ximo permitido, no puede crecer\n					if (asset.current > maxFromMargin + 1e-6) {\n						return asset.current;\n					}\n					return Math.max(safeMins[idx], maxFromMargin);\n				});\n\n				// Empezar desde los m\xEDnimos\n				let safeAllocations = [...safeMins];\n				let remaining = budget;\n\n				// Distribuir el presupuesto respetando los m\xE1ximos\n				let flex = normalized\n					.map((asset, index) => ({\n						index,\n						capacity: safeMaxs[index] - safeAllocations[index],\n					}))\n					.filter((item) => item.capacity > 1e-6);\n\n				while (flex.length && remaining > 1e-6) {\n					const weightSum = flex.reduce(\n						(sum, item) => sum + normalized[item.index].weight,\n						0\n					);\n					if (weightSum <= 0) break;\n\n					let consumed = 0;\n					const nextFlex = [];\n\n					flex.forEach((item) => {\n						const asset = normalized[item.index];\n						const share = (asset.weight / weightSum) * remaining;\n						if (share >= item.capacity - 1e-9) {\n							safeAllocations[item.index] += item.capacity;\n							consumed += item.capacity;\n						} else {\n							safeAllocations[item.index] += share;\n							consumed += share;\n							nextFlex.push({\n								index: item.index,\n								capacity: item.capacity - share,\n							});\n						}\n					});\n\n					if (consumed <= 1e-9) break;\n					remaining -= consumed;\n					flex = nextFlex;\n				}\n\n				const safeBreakdown = normalized.map((asset, index) => {\n					const desired = safeAllocations[index];\n					const addition = Math.max(0, desired - asset.current);\n					const units = asset.price > 0 ? addition / asset.price : 0;\n					return { ...asset, desired, addition, units };\n				});\n\n				// El presupuesto usado es el total del presupuesto menos el leftover\n				const safeInvested = budget - Math.max(0, remaining);\n\n				return {\n					breakdown: minimalResult.breakdown,\n					bestEffort: {\n						breakdown: safeBreakdown,\n						invested: safeInvested,\n					},\n					totals: {\n						mode: 'budget',\n						currentTotal,\n						finalTotal: minimalResult.totals.finalTotal,\n						budget: minimalResult.totals.invested,\n						invested: minimalResult.totals.invested,\n						leftover: Math.max(0, remaining),\n					},\n					warning,\n				};\n			}\n\n			return {\n				breakdown,\n				bestEffort,\n				totals: {\n					mode: 'budget',\n					currentTotal,\n					finalTotal,\n					budget,\n					invested,\n					leftover,\n				},\n				warning,\n			};\n		};\n\n		const applyUnitConstraints = (breakdown, totals, allowTransfers) => {\n			const targetSpend =\n				totals.mode === 'budget' ? totals.budget : totals.invested;\n\n			const adjusted = breakdown.map((asset) => {\n				let addition = asset.addition;\n				let units = asset.price > 0 ? asset.addition / asset.price : 0;\n\n				if (asset.wholeUnits && asset.price > 0) {\n					if (addition >= 0) {\n						if (totals.mode === 'minimal') {\n							units = Math.ceil(units - 1e-9);\n						} else {\n							units = Math.floor(units + 1e-9);\n						}\n					} else {\n						// Ventas: aproximar hacia cero para no sobre-vender\n						units = Math.ceil(units - 1e-9);\n					}\n					addition = units * asset.price;\n				}\n\n				return { ...asset, addition, units };\n			});\n\n			const buys = adjusted.reduce(\n				(sum, asset) => sum + Math.max(0, asset.addition),\n				0\n			);\n			const sells = adjusted.reduce(\n				(sum, asset) => sum + Math.max(0, -asset.addition),\n				0\n			);\n\n			const netSpent = adjusted.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n\n			// Calcular leftover: cuando hay presupuesto, usar el presupuesto disponible menos lo gastado\n			let leftover = 0;\n			if (totals.mode === 'budget') {\n				leftover = Math.max(0, targetSpend - netSpent);\n			} else if (allowTransfers && totals.budgetProvided > 0) {\n				// Cuando hay traspasos y presupuesto, calcular leftover basado en el presupuesto disponible\n				leftover = Math.max(0, totals.budgetProvided - netSpent);\n			}\n\n			if (leftover > 0.01) {\n				const fractional = adjusted.filter(\n					(asset) => !asset.wholeUnits || asset.price <= 0\n				);\n\n				fractional\n					.sort(\n						(a, b) =>\n							b.desired -\n							(b.current + b.addition) -\n							(a.desired - (a.current + a.addition))\n					)\n					.forEach((asset) => {\n						if (leftover <= 0.01) return;\n						const gap =\n							asset.desired - (asset.current + asset.addition);\n						if (gap <= 0) return;\n						const delta = Math.min(gap, leftover);\n						asset.addition += delta;\n						if (asset.price > 0 && !asset.wholeUnits) {\n							asset.units = asset.addition / asset.price;\n						}\n						leftover -= delta;\n					});\n			}\n\n			const finalSpent = adjusted.reduce(\n				(sum, asset) => sum + asset.addition,\n				0\n			);\n			const finalTotal = totals.currentTotal + finalSpent;\n\n			return {\n				breakdown: adjusted.map((asset) => ({\n					...asset,\n					finalShare:\n						finalTotal > 0\n							? (asset.current + asset.addition) / finalTotal\n							: 0,\n				})),\n				spent: finalSpent,\n				leftover,\n				finalTotal,\n				buys,\n				sells,\n				net: finalSpent,\n			};\n		};\n\n		const generateStepGuide = (breakdown, totals, bestApplied) => {\n			// Usar bestApplied si existe (aportaci\xF3n real), sino usar breakdown (lo ideal)\n			const activeBreakdown =\n				bestApplied && bestApplied.breakdown\n					? bestApplied.breakdown\n					: breakdown;\n\n			const steps = [];\n			let stepNumber = 1;\n\n			// Separar ventas y compras, diferenciando fondos (no wholeUnits) de ETFs (wholeUnits)\n			const sales = activeBreakdown\n				.filter((asset) => asset.addition < -1e-6)\n				.map((asset) => ({\n					name: asset.name,\n					amount: Math.abs(asset.addition),\n					units:\n						asset.units && asset.wholeUnits && asset.price > 0\n							? Math.abs(Math.round(asset.units))\n							: null,\n					price: asset.price,\n					wholeUnits: asset.wholeUnits,\n				}));\n\n			const purchases = activeBreakdown\n				.filter((asset) => asset.addition > 1e-6)\n				.map((asset) => ({\n					name: asset.name,\n					amount: asset.addition,\n					units:\n						asset.units && asset.wholeUnits && asset.price > 0\n							? Math.round(asset.units)\n							: null,\n					price: asset.price,\n					wholeUnits: asset.wholeUnits,\n				}));\n\n			// Separar fondos de ETFs\n			const fundSales = sales.filter((s) => !s.wholeUnits);\n			const etfSales = sales.filter((s) => s.wholeUnits);\n			const fundPurchases = purchases.filter((p) => !p.wholeUnits);\n			const etfPurchases = purchases.filter((p) => p.wholeUnits);\n\n			// Calcular totales\n			const totalFundSales = fundSales.reduce(\n				(sum, s) => sum + s.amount,\n				0\n			);\n			const totalEtfSales = etfSales.reduce(\n				(sum, s) => sum + s.amount,\n				0\n			);\n			const totalFundPurchases = fundPurchases.reduce(\n				(sum, p) => sum + p.amount,\n				0\n			);\n			const totalEtfPurchases = etfPurchases.reduce(\n				(sum, p) => sum + p.amount,\n				0\n			);\n			const totalSales = totalFundSales + totalEtfSales;\n			const totalPurchases = totalFundPurchases + totalEtfPurchases;\n			const netNeeded = totals.allowTransfers\n				? Math.max(0, totalPurchases - totalSales)\n				: totalPurchases;\n\n			// Si hay traspasos habilitados, hacer traspasos directos entre fondos\n			if (totals.allowTransfers) {\n				// Crear traspasos directos entre fondos\n				const salesToProcess = fundSales.map((s) => ({ ...s }));\n				const purchasesToProcess = fundPurchases.map((p) => ({ ...p }));\n\n				// Emparejar ventas con compras de fondos (traspasos directos)\n				while (\n					salesToProcess.length > 0 &&\n					purchasesToProcess.length > 0\n				) {\n					const sale = salesToProcess[0];\n					const purchase = purchasesToProcess[0];\n\n					const transferAmount = Math.min(\n						sale.amount,\n						purchase.amount\n					);\n\n					// Solo a\xF1adir paso si el importe es significativo\n					if (transferAmount > 0.01) {\n						steps.push({\n							text: \\`<strong>\\${stepNumber}. Traspasa \\${numberFormatter.format(transferAmount)} </strong> | <strong>\\${sale.name}</strong> \u2192 <strong>\\${purchase.name}</strong>\\`,\n							type: 'transfer',\n						});\n						stepNumber++;\n					}\n\n					// Actualizar montos restantes\n					sale.amount -= transferAmount;\n					purchase.amount -= transferAmount;\n\n					if (sale.amount < 1e-6) {\n						salesToProcess.shift();\n					}\n					if (purchase.amount < 1e-6) {\n						purchasesToProcess.shift();\n					}\n				}\n\n				// Si quedan ventas de fondos, seguir emparej\xE1ndolas con las compras restantes\n				while (\n					salesToProcess.length > 0 &&\n					purchasesToProcess.length > 0\n				) {\n					const sale = salesToProcess[0];\n					const purchase = purchasesToProcess[0];\n\n					const transferAmount = Math.min(\n						sale.amount,\n						purchase.amount\n					);\n\n					// Solo a\xF1adir paso si el importe es significativo\n					if (transferAmount > 0.01) {\n						steps.push({\n							text: \\`<strong>\\${stepNumber}. Traspasa \\${numberFormatter.format(transferAmount)} </strong> | <strong>\\${sale.name}</strong> \u2192 <strong>\\${purchase.name}</strong>\\`,\n							type: 'transfer',\n						});\n						stepNumber++;\n					}\n\n					sale.amount -= transferAmount;\n					purchase.amount -= transferAmount;\n\n					if (sale.amount < 1e-6) {\n						salesToProcess.shift();\n					}\n					if (purchase.amount < 1e-6) {\n						purchasesToProcess.shift();\n					}\n				}\n\n				// ETFs: vender primero (no se pueden traspasar, solo vender/comprar)\n				etfSales.forEach((sale) => {\n					steps.push({\n						text: \\`<strong>\\${stepNumber}. Vende \\${numberFormatter.format(sale.amount)} </strong> | <strong>\\${sale.name}</strong>\\`,\n						type: 'transfer',\n					});\n					stepNumber++;\n				});\n\n				// Si hay dinero adicional necesario despu\xE9s de los traspasos\n				if (netNeeded > 1e-6) {\n					steps.push({\n						text: \\`<strong>\\${stepNumber}. Aporta \\${numberFormatter.format(netNeeded)} adicionales para completar las compras</strong>\\`,\n						type: 'contribution',\n					});\n					stepNumber++;\n				}\n\n				// Compras de fondos que no fueron cubiertas por traspasos\n				purchasesToProcess.forEach((purchase) => {\n					if (purchase.amount > 1e-6) {\n						steps.push({\n							text: \\`<strong>\\${stepNumber}. Compra \\${numberFormatter.format(purchase.amount)} </strong> | <strong>\\${purchase.name}</strong>\\`,\n							type: 'purchase',\n						});\n						stepNumber++;\n					}\n				});\n\n				// Compras de ETFs\n				etfPurchases.forEach((purchase) => {\n					steps.push({\n						text: \\`<strong>\\${stepNumber}. Compra \\${numberFormatter.format(purchase.amount)} </strong> | <strong>\\${purchase.name}</strong>\\`,\n						type: 'purchase',\n					});\n					stepNumber++;\n				});\n			} else {\n				// Sin traspasos, mostrar primero la aportaci\xF3n necesaria\n				if (netNeeded > 1e-6) {\n					steps.push({\n						text: \\`<strong>\\${stepNumber}. Aporta \\${numberFormatter.format(netNeeded)}</strong>\\`,\n						type: 'contribution',\n					});\n					stepNumber++;\n				}\n\n				// Mostrar las compras\n				purchases.forEach((purchase) => {\n					steps.push({\n						text: \\`<strong>\\${stepNumber}. Compra \\${numberFormatter.format(purchase.amount)} </strong> | <strong>\\${purchase.name}</strong>\\`,\n						type: 'purchase',\n					});\n					stepNumber++;\n				});\n			}\n\n			// Si no hay acciones\n			if (steps.length === 0) {\n				steps.push({\n					text: '<strong>1. No se requieren acciones. Tu cartera ya cumple con los objetivos dentro del margen establecido.</strong>',\n					type: 'info',\n				});\n			}\n\n			// Mostrar leftover si existe\n			if (totals.leftover > 0.01) {\n				steps.push({\n					text: \\`<strong>Nota:</strong> Quedan \\${numberFormatter.format(totals.leftover)} sin asignar debido a restricciones de unidades completas.\\`,\n					type: 'info',\n				});\n			}\n\n			return steps;\n		};\n\n		const renderResults = (breakdown, totals, bestApplied) => {\n			const summaryItems = [\n				{\n					label: 'Total actual',\n					value: numberFormatter.format(totals.currentTotal),\n				},\n				{\n					label: 'Total tras inversi\xF3n',\n					value: numberFormatter.format(totals.finalTotal),\n				},\n				{\n					label: totals.allowTransfers\n						? 'Importe neto (compras - ventas)'\n						: totals.mode === 'budget'\n							? 'Importe a invertir'\n							: 'M\xEDnimo a invertir',\n					value: numberFormatter.format(totals.invested),\n				},\n			];\n\n			if (totals.mode === 'budget') {\n				const budgetItems = [\n					{\n						label: 'Presupuesto calculado',\n						value: numberFormatter.format(totals.budget),\n					},\n				];\n\n				if (\n					totals.allowTransfers &&\n					typeof totals.budgetProvided !== 'undefined'\n				) {\n					budgetItems.push({\n						label: 'Presupuesto indicado',\n						value: numberFormatter.format(totals.budgetProvided),\n					});\n				}\n\n				if (totals.allowTransfers && totals.extraNeeded > 0.01) {\n					budgetItems.push({\n						label: 'Extra para evitar cruzar tipos',\n						value: numberFormatter.format(totals.extraNeeded),\n					});\n				}\n\n				summaryItems.push(...budgetItems);\n\n				if (totals.leftover > 0.01) {\n					summaryItems.push({\n						label: 'Sobrante sin asignar',\n						value: numberFormatter.format(totals.leftover),\n					});\n				}\n			}\n\n			if (\n				totals.allowTransfers &&\n				totals.mode !== 'budget' &&\n				totals.extraNeeded > 0.01\n			) {\n				summaryItems.push({\n					label: 'Extra necesario para rebalancear por tipos',\n					value: numberFormatter.format(totals.extraNeeded),\n				});\n			}\n\n			if (totals.allowTransfers && totals.sells > 0.01) {\n				summaryItems.push(\n					{\n						label: 'Compras estimadas',\n						value: numberFormatter.format(totals.buys),\n					},\n					{\n						label: 'Ventas estimadas',\n						value: numberFormatter.format(totals.sells),\n					}\n				);\n			}\n\n			summaryItems.push({\n				label: 'Margen aplicado',\n				value: \\`\\${marginNumberFormatter.format(getMarginValue())} %\\`,\n			});\n\n			summaryEl.innerHTML = summaryItems\n				.map(\n					(item) => \\`\n				<div class=\"rounded-lg border border-gray-700 bg-gray-800/70 p-3 sm:p-4\">\n					<div class=\"text-xs text-gray-400 sm:text-sm\">\\${item.label}</div>\n					<div class=\"mt-1 text-lg font-bold text-gray-100 sm:text-xl\">\\${item.value}</div>\n				</div>\\`\n				)\n				.join('');\n\n			tbody.innerHTML = '';\n			breakdown.forEach((asset, index) => {\n				const row = document.createElement('tr');\n				row.className =\n					index % 2 === 0 ? 'bg-gray-800/50' : 'bg-gray-900/50';\n\n				const bestAsset =\n					bestApplied && bestApplied.breakdown\n						? bestApplied.breakdown[index]\n						: null;\n\n				const unitsLabel =\n					asset.price > 0\n						? asset.wholeUnits\n							? \\`\\${asset.units.toFixed(0)} ud\\`\n							: unitFormatter.format(asset.units)\n						: '\u2014';\n				const additionClass =\n					asset.addition > 0\n						? 'text-green-400'\n						: asset.addition < 0\n							? 'text-red-400'\n							: 'text-gray-300';\n\n				const bestAddition =\n					bestAsset && typeof bestAsset.addition === 'number'\n						? bestAsset.addition\n						: null;\n				const bestClass =\n					bestAddition === null\n						? ''\n						: bestAddition > 0\n							? 'text-green-400'\n							: bestAddition < 0\n								? 'text-red-400'\n								: 'text-gray-300';\n				const bestUnitsLabel =\n					bestAsset && bestAsset.price > 0\n						? bestAsset.wholeUnits\n							? \\`\\${bestAsset.units.toFixed(0)} ud\\`\n							: unitFormatter.format(bestAsset.units)\n						: bestAsset\n							? '\u2014'\n							: null;\n\n				row.innerHTML = \\`\n					<td class=\"px-3 py-2 text-xs text-gray-200 sm:px-4 sm:py-3 sm:text-sm\">\\${asset.name}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">\\${numberFormatter.format(asset.current)}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">\\${numberFormatter.format(asset.desired)}</td>\n					<td class=\"px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm \\${additionClass}\">\\${numberFormatter.format(\n						asset.addition\n					)}</td>\n					<td class=\"px-3 py-2 text-xs font-semibold sm:px-4 sm:py-3 sm:text-sm \\${bestClass}\">\\${\n						bestAsset ? numberFormatter.format(bestAddition) : '\u2014'\n					}</td>\n					<td class=\"px-3 py-2 text-xs text-gray-300 sm:px-4 sm:py-3 sm:text-sm\">\\${unitsLabel}</td>\n					<td class=\"px-3 py-2 text-xs font-medium text-blue-400 sm:px-4 sm:py-3 sm:text-sm\">\\${percentFormatter.format(asset.finalShare)}</td>\n				\\`;\n				tbody.appendChild(row);\n			});\n\n			const positiveAssets = breakdown.filter(\n				(asset) => asset.addition > 0\n			);\n			const negativeAssets = breakdown.filter(\n				(asset) => asset.addition < 0\n			);\n\n			if (!positiveAssets.length) {\n				if (totals.allowTransfers && negativeAssets.length) {\n					const sellAsset = negativeAssets.reduce((prev, current) =>\n						-current.addition > -prev.addition ? current : prev\n					);\n					adviceEl.textContent = \\`Solo necesitas traspasos: reduce \\${sellAsset.name} en \\${numberFormatter.format(\n						Math.abs(sellAsset.addition)\n					)} y redistribuye seg\xFAn la tabla.\\`;\n				} else {\n					adviceEl.textContent =\n						'Ya cumples la distribuci\xF3n objetivo; no es necesario aportar m\xE1s.';\n				}\n				return;\n			}\n\n			const maxAsset = positiveAssets.reduce((prev, current) =>\n				current.addition > prev.addition ? current : prev\n			);\n\n			const baseMessage =\n				totals.mode === 'budget'\n					? \\`Con el presupuesto indicado empieza por \\${maxAsset.name}, requiere \\${numberFormatter.format(\n							maxAsset.addition\n						)}.\\`\n					: \\`Para alcanzar la distribuci\xF3n dentro del margen aporta primero en \\${maxAsset.name}, necesita \\${numberFormatter.format(\n							maxAsset.addition\n						)}.\\`;\n\n			const leftoverMessage =\n				totals.mode === 'budget' && totals.leftover > 0.01\n					? \\` Quedar\xE1n \\${numberFormatter.format(\n							totals.leftover\n						)} libres al no poder comprar fracciones.\\`\n					: '';\n\n			adviceEl.textContent = \\`\\${baseMessage}\\${leftoverMessage}\\`;\n\n			// Generar y mostrar gu\xEDa paso a paso\n			const steps = generateStepGuide(breakdown, totals, bestApplied);\n			if (steps.length > 0) {\n				stepList.innerHTML = steps\n					.map((step) => {\n						let borderColor = 'border-gray-700';\n						let bgColor = 'bg-gray-700/30';\n\n						if (step.type === 'transfer') {\n							// Naranja para traspasos\n							borderColor = 'border-orange-500/50';\n							bgColor = 'bg-orange-600/10';\n						} else if (step.type === 'purchase') {\n							// Verde para compras\n							borderColor = 'border-green-500/50';\n							bgColor = 'bg-green-950/30';\n						} else if (step.type === 'contribution') {\n							// Gris para aportaciones\n							borderColor = 'border-gray-600/50';\n							bgColor = 'bg-gray-700/30';\n						} else if (step.type === 'info') {\n							// Vainilla/beige para notas\n							borderColor = 'border-yellow-200/30';\n							bgColor = 'bg-yellow-50/10';\n						}\n\n						return \\`<li class=\"rounded-lg border \\${borderColor} \\${bgColor} p-3\">\\${step.text}</li>\\`;\n					})\n					.join('');\n				stepGuide.hidden = false;\n			} else {\n				stepGuide.hidden = true;\n			}\n		};\n\n		const showError = (message) => {\n			errorBox.textContent = message;\n			errorBox.hidden = false;\n			resultsSection.hidden = true;\n		};\n\n		const clearError = () => {\n			errorBox.hidden = true;\n			errorBox.textContent = '';\n		};\n\n		const showWarning = (warning) => {\n			if (warning) {\n				errorBox.innerHTML = warning.message;\n				errorBox.hidden = false;\n			} else {\n				clearError();\n			}\n		};\n\n		// Guardar estado en localStorage\n		const saveFormState = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const state = {\n					budget: budgetInput.value,\n					margin: marginInput.value,\n					allowTransfers: transfersEnabled(),\n					assets: rows.map((row) => ({\n						name: row.name,\n						isin: row.isin,\n						current: row.current,\n						price: row.price,\n						target: row.target,\n						wholeUnits: row.wholeUnits,\n						includedInCalculation: row.includedInCalculation,\n					})),\n				};\n				localStorage.setItem(\n					'investmentCalculatorState',\n					JSON.stringify(state)\n				);\n			} catch (e) {\n				console.warn('No se pudo guardar el estado:', e);\n			}\n		};\n\n		// Cargar estado desde localStorage\n		const loadFormState = () => {\n			try {\n				const saved = localStorage.getItem('investmentCalculatorState');\n				if (saved) {\n					const state = JSON.parse(saved);\n\n					// Cargar budget y margin\n					if (state.budget !== undefined)\n						budgetInput.value = state.budget;\n					if (state.margin !== undefined)\n						marginInput.value = state.margin;\n					if (typeof state.allowTransfers !== 'undefined') {\n						setTransfersToggle(Boolean(state.allowTransfers));\n					}\n\n					// Limpiar y recrear filas\n					if (state.assets && state.assets.length > 0) {\n						rowsContainer.innerHTML = '';\n						state.assets.forEach((asset) => {\n							const fragment =\n								rowTemplate.content.cloneNode(true);\n							const row = fragment.querySelector('[data-row]');\n							rowsContainer.appendChild(fragment);\n							initializeRow(row, asset);\n						});\n					}\n\n					updateCurrentDistribution();\n					autoCalculate();\n				}\n			} catch (e) {\n				console.warn('No se pudo cargar el estado:', e);\n			}\n		};\n\n		// Auto-calcular\n		let autoCalculateTimeout;\n		const autoCalculate = () => {\n			clearTimeout(autoCalculateTimeout);\n			autoCalculateTimeout = setTimeout(() => {\n				try {\n					const allRows = getRows();\n					// Filtrar solo los activos incluidos en el c\xE1lculo\n					const rows = allRows.filter(\n						(asset) => asset.includedInCalculation\n					);\n\n					if (rows.length === 0) {\n						showError(\n							'Debe haber al menos un activo incluido en el c\xE1lculo'\n						);\n						return;\n					}\n\n					const budget = Math.max(0, sanitize(budgetInput.value));\n					const allowMove = transfersEnabled();\n					const result = allowMove\n						? computeWithTransfers(rows, budget)\n						: budget > 0\n							? allocateWithBudget(rows, budget)\n							: minimalContribution(rows);\n\n					// Verificar si realmente hay ventas/traspasos en el resultado\n					// Si no hay ventas, tratar como si no hubiera traspasos habilitados\n					const hasActualTransfers =\n						allowMove &&\n						result.breakdown.some(\n							(asset) => asset.addition < -1e-6\n						);\n\n					const appliedMain = applyUnitConstraints(\n						result.breakdown,\n						result.totals,\n						hasActualTransfers\n					);\n\n					let appliedBest = null;\n					if (result.bestEffort) {\n						const bestTotals = {\n							...result.totals,\n							invested: result.bestEffort.invested,\n							budget,\n						};\n						appliedBest = applyUnitConstraints(\n							result.bestEffort.breakdown,\n							bestTotals,\n							hasActualTransfers\n						);\n					}\n\n					const totals = {\n						...result.totals,\n						invested: hasActualTransfers\n							? appliedMain.net\n							: appliedMain.spent,\n						leftover: appliedMain.leftover,\n						finalTotal: appliedMain.finalTotal,\n						buys: appliedMain.buys,\n						sells: appliedMain.sells,\n						allowTransfers: hasActualTransfers,\n						bestEffort: appliedBest,\n					};\n\n					resultsSection.hidden = false;\n					renderResults(appliedMain.breakdown, totals, appliedBest);\n\n					// Mostrar warning si existe\n					if (result.warning) {\n						showWarning(result.warning);\n					} else {\n						clearError();\n					}\n				} catch (err) {\n					showError(err.message);\n				}\n			}, 500);\n		};\n\n		// Event listeners para inputs principales\n		budgetInput.addEventListener('input', () => {\n			saveFormState();\n			autoCalculate();\n		});\n\n		marginInput.addEventListener('input', () => {\n			saveFormState();\n			autoCalculate();\n		});\n\n		// Prevenir submit del form\n		form.addEventListener('submit', (event) => {\n			event.preventDefault();\n		});\n\n		// Exportar datos a JSON\n		const exportData = () => {\n			try {\n				const rows = getRows({ strict: false });\n				const data = {\n					version: '1.0',\n					budget: budgetInput.value || '',\n					margin: marginInput.value || '',\n					allowTransfers: transfersEnabled(),\n					assets: rows.map((row) => ({\n						name: row.name,\n						isin: row.isin || '',\n						current: row.current,\n						price: row.price || '',\n						target: row.target,\n						wholeUnits: row.wholeUnits,\n						includedInCalculation: row.includedInCalculation,\n					})),\n				};\n\n				const jsonStr = JSON.stringify(data, null, 2);\n				const blob = new Blob([jsonStr], { type: 'application/json' });\n				const url = URL.createObjectURL(blob);\n				const a = document.createElement('a');\n				a.href = url;\n				a.download = \\`calculadora-inversion-\\${new Date().toISOString().split('T')[0]}.json\\`;\n				document.body.appendChild(a);\n				a.click();\n				document.body.removeChild(a);\n				URL.revokeObjectURL(url);\n			} catch (error) {\n				showError('Error al exportar los datos: ' + error.message);\n			}\n		};\n\n		// Importar datos desde JSON\n		const importData = (file) => {\n			const reader = new FileReader();\n			reader.onload = (e) => {\n				try {\n					const data = JSON.parse(e.target.result);\n\n					if (!data.assets || !Array.isArray(data.assets)) {\n						throw new Error('Formato de archivo inv\xE1lido');\n					}\n\n					// Cargar presupuesto y margen\n					if (data.budget !== undefined)\n						budgetInput.value = data.budget || '';\n					if (data.margin !== undefined)\n						marginInput.value = data.margin || '';\n					if (typeof data.allowTransfers !== 'undefined') {\n						setTransfersToggle(Boolean(data.allowTransfers));\n					}\n\n					// Limpiar y recrear filas\n					rowsContainer.innerHTML = '';\n					data.assets.forEach((asset) => {\n						const fragment = rowTemplate.content.cloneNode(true);\n						const row = fragment.querySelector('[data-row]');\n						rowsContainer.appendChild(fragment);\n						initializeRow(row, {\n							name: asset.name || '',\n							isin: asset.isin || null,\n							current: asset.current || null,\n							price: asset.price || null,\n							target: asset.target || 0,\n							wholeUnits: Boolean(asset.wholeUnits),\n							includedInCalculation:\n								typeof asset.includedInCalculation ===\n								'undefined'\n									? true\n									: Boolean(asset.includedInCalculation),\n						});\n					});\n\n					// Si no hay activos, crear uno vac\xEDo\n					if (data.assets.length === 0) {\n						const fragment = rowTemplate.content.cloneNode(true);\n						const row = fragment.querySelector('[data-row]');\n						rowsContainer.appendChild(fragment);\n						initializeRow(row);\n					}\n\n					updateCurrentDistribution();\n					saveFormState();\n					autoCalculate();\n					clearError();\n\n					// Refrescar precios de todos los ISINs\n					setTimeout(() => refreshAllPrices(), 500);\n				} catch (error) {\n					showError('Error al importar los datos: ' + error.message);\n				}\n			};\n			reader.onerror = () => {\n				showError('Error al leer el archivo');\n			};\n			reader.readAsText(file);\n		};\n\n		exportBtn.addEventListener('click', exportData);\n\n		importBtn.addEventListener('click', () => {\n			importFileInput.click();\n		});\n\n		importFileInput.addEventListener('change', (e) => {\n			const file = e.target.files[0];\n			if (file) {\n				if (\n					file.type !== 'application/json' &&\n					!file.name.endsWith('.json')\n				) {\n					showError('El archivo debe ser un JSON v\xE1lido');\n					return;\n				}\n				importData(file);\n				// Limpiar el input para permitir cargar el mismo archivo de nuevo\n				e.target.value = '';\n			}\n		});\n\n		resetBtn.addEventListener('click', () => {\n			// Limpiar localStorage\n			localStorage.removeItem('investmentCalculatorState');\n\n			form.reset();\n			setTransfersToggle(false);\n			rowsContainer.innerHTML = '';\n			initialAssets.forEach((asset) => {\n				const fragment = rowTemplate.content.cloneNode(true);\n				const row = fragment.querySelector('[data-row]');\n				rowsContainer.appendChild(fragment);\n				initializeRow(row, asset);\n			});\n			resultsSection.hidden = true;\n			clearError();\n			updateCurrentDistribution();\n			saveFormState();\n			autoCalculate();\n		});\n\n		// Cargar estado inicial al cargar la p\xE1gina\n		loadFormState();\n\n		// Refrescar precios de todos los ISINs despu\xE9s de cargar\n		setTimeout(() => refreshAllPrices(), 1000);\n	<\/script> "])), maybeRenderHead(), defaultAssets.map((asset) => renderTemplate`<div class="relative rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-md sm:p-4" data-row data-astro-cid-4w4x4o4c> <button type="button" data-action="delete-row" class="absolute top-2 right-2 rounded-md p-1.5 text-gray-400 transition-colors hover:bg-red-600/20 hover:text-red-400 focus:ring-2 focus:ring-red-500 focus:outline-none" title="Eliminar activo" data-astro-cid-4w4x4o4c> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" data-astro-cid-4w4x4o4c> <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" data-astro-cid-4w4x4o4c></path> </svg> </button> <div class="grid grid-cols-1 gap-3 sm:grid-cols-2 sm:gap-4 lg:grid-cols-8" data-astro-cid-4w4x4o4c> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
ISIN
</label> <input data-field="isin" type="text"${addAttribute(asset.isin || "", "value")} placeholder="ES0123456789" class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2 lg:col-span-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Activo
</label> <input data-field="name" type="text" required${addAttribute(asset.name, "value")} class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Valor actual (&euro;)
</label> <input data-field="current" type="number" min="0" step="0.01" required${addAttribute(asset.current, "value")} class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-price-wrapper data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Precio unidad (&euro;)
</label> <input data-field="price" type="number" min="0" step="0.01"${addAttribute(asset.price || "", "value")}${addAttribute(!asset.wholeUnits, "disabled")} class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Solo unidades completas?
</label> <button type="button" role="switch" data-field="whole"${addAttribute(
    asset.wholeUnits ? "true" : "false",
    "aria-checked"
  )}${addAttribute(`Activar unidades completas para ${asset.name}`, "aria-label")}${addAttribute(`relative inline-flex h-8 w-14 items-center rounded-full transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none ${asset.wholeUnits ? "bg-blue-600" : "bg-gray-600"}`, "class")} data-astro-cid-4w4x4o4c> <span${addAttribute(`inline-block h-6 w-6 transform rounded-full bg-white transition-transform ${asset.wholeUnits ? "translate-x-7" : "translate-x-1"}`, "class")} data-astro-cid-4w4x4o4c></span> </button> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Objetivo (%)
</label> <input data-field="target" type="number" min="0" max="100" step="0.1" required${addAttribute(asset.target, "value")} class="rounded-md border border-gray-600 bg-gray-700 px-3 py-2 text-sm text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none" data-astro-cid-4w4x4o4c> </div> <div class="flex flex-col gap-2" data-astro-cid-4w4x4o4c> <label class="text-sm font-medium text-gray-300" data-astro-cid-4w4x4o4c>
Incluir en clculo
</label> <button type="button" role="switch" data-field="included"${addAttribute(
    typeof asset.includedInCalculation === "undefined" || asset.includedInCalculation ? "true" : "false",
    "aria-checked"
  )}${addAttribute(`Incluir ${asset.name} en el c\xE1lculo`, "aria-label")}${addAttribute(`relative inline-flex h-8 w-14 items-center rounded-full transition-colors focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 focus:outline-none ${typeof asset.includedInCalculation === "undefined" || asset.includedInCalculation ? "bg-blue-600" : "bg-gray-600"}`, "class")} data-astro-cid-4w4x4o4c> <span${addAttribute(`inline-block h-6 w-6 transform rounded-full bg-white transition-transform ${typeof asset.includedInCalculation === "undefined" || asset.includedInCalculation ? "translate-x-7" : "translate-x-1"}`, "class")} data-astro-cid-4w4x4o4c></span> </button> </div> </div> </div>`), defineScriptVars({ defaultAssets })) })} `;
}, "/home/runner/work/portfolio/portfolio/src/pages/tools/investmentCalculator.astro", void 0);

const $$file = "/home/runner/work/portfolio/portfolio/src/pages/tools/investmentCalculator.astro";
const $$url = "/tools/investmentCalculator";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: $$InvestmentCalculator,
	file: $$file,
	url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
